# Test that cf-promises -T tags a directory correctly

body common control
{
      inputs => { "../../default.cf.sub" };
      bundlesequence => { default("$(this.promise_filename)") };
      version => "1.0";
}

bundle agent init
{
  vars:
      "masters" slist => { "promises.cf", "x.cf", "y.cf" };

  methods:
      "rsync"
      usebundle => default_cf_sub_copydir("$(this.promise_dirname)/testdir",
                                          $(G.testdir));

      "master2cf"
      usebundle => default_cf_sub_copyfile("$(G.testdir)/$(masters).master",
                                           "$(G.testdir)/$(masters)");

      "make ignored file 1"
      usebundle => default_cf_sub_makefile("$(G.testdir)/ignoreme",
                                           "fnord $(sys.date)");

      "make ignored file 2"
      usebundle => default_cf_sub_makefile("$(G.testdir)/ignoredir/2",
                                           "fnord $(sys.date)");
}

bundle agent test
{
  vars:
      "simulated_validated_ok" string => '
{
 "timestamp": 1234,
 "checksum": "4b974a13b5473cfbf60edfb66b201a364d38960f"
}
';

      "simulated_validated_bad" string => '
{
 "timestamp": 1234,
 "checksum": "1234567890123456789012345678901234567890"
}
';

  methods:
      "tag1" usebundle => test_tag($(this.promiser),
                                   "make new cf_promises_validated and cf_promises_release_id");
      "read1" usebundle => test_read($(this.promiser));

      "rm r_id" usebundle => default_fini($(test_read.rf));
      "tag2" usebundle => test_tag($(this.promiser),
                                   "recreate cf_promises_release_id even if cf_promises_validated is OK");
      "read2" usebundle => test_read($(this.promiser));

      "make good validated file"
      usebundle => default_cf_sub_makefile("$(G.testdir)/cf_promises_validated",
                                           $(simulated_validated_ok));

      "tag3" usebundle => test_tag($(this.promiser),
                                   "don't touch good cf_promises_validated and cf_promises_release_id");
      "read3" usebundle => test_read($(this.promiser));

      "make bad validated file"
      usebundle => default_cf_sub_makefile("$(G.testdir)/cf_promises_validated",
                                           $(simulated_validated_bad));

      "tag4" usebundle => test_tag($(this.promiser),
                                   "overwrite bad cf_promises_validated");
      "read4" usebundle => test_read($(this.promiser));

}

bundle agent test_tag(vary, desc)
{
  classes:
      "tagged_$(vary)"
      expression => returnszero("$(sys.cf_promises) -T $(G.testdir) -D$(vary)",
                                "noshell"),
      scope => "namespace";

  reports:
      "Case $(vary): $(desc)";

    DEBUG::
      "Case $(vary): $failed to tag $(G.testdir)"
      ifvarclass => "!tagged_$(vary)";

      "Case $(vary): tagged $(G.testdir)"
      ifvarclass => "tagged_$(vary)";
}

bundle agent test_read(suffix)
{
  vars:
      "vf" string => "$(G.testdir)/cf_promises_validated";
      "rf" string => "$(G.testdir)/cf_promises_release_id";

      "v_$(suffix)" data => readjson($(vf), 4k),
      ifvarclass => "have_vf_$(suffix)";

      "v_$(suffix)_str" string => format("%S", "v_$(suffix)"),
      handle => "v_$(suffix)_str",
      ifvarclass => "have_vf_$(suffix)";

      "r_$(suffix)" data => readjson($(rf), 4k),
      ifvarclass => "have_rf_$(suffix)";

      "r_$(suffix)_str" string => format("%S", "r_$(suffix)"),
      handle => "r_$(suffix)_str",
      ifvarclass => "have_rf_$(suffix)";

  classes:
      "have_vf_$(suffix)" expression => fileexists($(vf)),
      scope => "namespace";

      "have_rf_$(suffix)" expression => fileexists($(rf)),
      scope => "namespace";

  reports:
    DEBUG::
      "Case $(suffix): $(vf) = $(v_$(suffix)_str)"
      depends_on => { "v_$(suffix)_str" },
      ifvarclass => "have_vf_$(suffix)";

      "Case $(suffix): Missing validation file $(vf)"
      ifvarclass => "!have_vf_$(suffix)";

      "Case $(suffix): $(rf) = $(r_$(suffix)_str)"
      depends_on => { "r_$(suffix)_str" },
      ifvarclass => "have_rf_$(suffix)";

      "Case $(suffix): Missing release ID file $(rf)"
      ifvarclass => "!have_rf_$(suffix)";
}

bundle agent check
{
  vars:
      "expected_checksum" string => "4b974a13b5473cfbf60edfb66b201a364d38960f";
      "tests" slist => { "1", "2", "3", "4" };

  classes:

      "correct_timestamp_1" expression => "any";
      "correct_release_1" expression => strcmp("$(test_read.r_read1[releaseId])",
                                             $(expected_checksum));
      "correct_checksum_1" expression => strcmp("$(test_read.v_read1[checksum])",
                                              $(expected_checksum));

      "correct_timestamp_2" expression => "any";
      "correct_release_2" expression => strcmp("$(test_read.r_read2[releaseId])",
                                             $(expected_checksum));
      "correct_checksum_2" expression => strcmp("$(test_read.v_read2[checksum])",
                                              $(expected_checksum));

      "correct_timestamp_3" expression => strcmp("$(test_read.v_read3[timestamp])",
                                                 "1234");
      "correct_release_3" expression => strcmp("$(test_read.r_read3[releaseId])",
                                             $(expected_checksum));
      "correct_checksum_3" expression => strcmp("$(test_read.v_read3[checksum])",
                                              $(expected_checksum));

      # anything except the bad timestamp is OK
      "correct_timestamp_4" not => strcmp("$(test_read.v_read4[timestamp])",
                                          "1234");
      "correct_release_4" expression => strcmp("$(test_read.r_read4[releaseId])",
                                             $(expected_checksum));
      "correct_checksum_4" expression => strcmp("$(test_read.v_read4[checksum])",
                                              $(expected_checksum));

      "ok" and => {
                    "have_vf_read1", "have_rf_read1", "tagged_tag1", "correct_timestamp_1", "correct_release_1", "correct_checksum_1",
                    "have_vf_read2", "have_rf_read2", "tagged_tag2", "correct_timestamp_2", "correct_release_2", "correct_checksum_2",
                    "have_vf_read3", "have_rf_read3", "tagged_tag3", "correct_timestamp_3", "correct_release_3", "correct_checksum_3",
                    "have_vf_read4", "have_rf_read4", "tagged_tag4", "correct_timestamp_4", "correct_release_4", "correct_checksum_4",
      };

  reports:
    DEBUG::
      "Case $(tests): the timestamp was correct or ignored"
      ifvarclass => "correct_timestamp_$(tests)";

      "Case $(tests): the timestamp was incorrect, actual $(test_read.v_read$(tests)[timestamp])"
      ifvarclass => "!correct_timestamp_$(tests)";

      "Case $(tests): the checksum was correct ($(expected_checksum))"
      ifvarclass => "correct_checksum_$(tests)";

      "Case $(tests): the checksum was incorrect, expected $(expected_checksum) vs. actual $(test_read.v_read$(tests)[checksum])"
      ifvarclass => "!correct_checksum_$(tests)";

      "Case $(tests): the release ID was correct ($(expected_checksum))"
      ifvarclass => "correct_release_$(tests)";

      "Case $(tests): the release ID was incorrect, expected $(expected_checksum) vs. actual $(test_read.r_read$(tests)[releaseId])"
      ifvarclass => "!correct_release_$(tests)";

    ok::
      "$(this.promise_filename) Pass";
    !ok::
      "$(this.promise_filename) FAIL";
}
