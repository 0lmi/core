

# A bundle is a collection of promises, i.e. objects, types and body labels
# A body is a convenient collection of attribute constraints for a type of promise
# Since bundles pertain to specific types of promises, the have types themselves


# Each component has its own body called control()

#     body cfagent control()
#     body cfservd control
#     body cfenvd  control
#     body cfrun   control

#
# This parser should be able to construct the promise graph in
# matrix form and make unique identifiers for each promise so that
# they can be instrumented. Dependency chains should be identified
#
# Conflicts should be analysed automatically. Loops should be
# expanded
#

#####################################################################

body agent control
   {
   bundlesequence => "update";

   inputs          => { "update.cf", "main.cf" };
   version         => "1.3.3"; # search for files in subdir?

    linux::

      inputs => { "update.cf", "main.cf" , "linux.cf" };


   }

#########################################################

body monitor control()
   {
   emailfrom => "mark@iu.hio.no";
   emailto => "cfengine@domain.tld";

   trustnew => "0.7";

   # on linux

   linux::

   # Sensor => ReadFile("/proc/cpu/temperature");
   }

###################################################################

bundle agent myPromises(daemon_list,s1,s2)   # policy version 1.0
   {
   classes:

     "alias"   or => { "solaris&x86|linux|mac" , UserExists("mark") };

   vars:

     "myname"  string => "value in quotes" ,
               policy => constant;

     "derived" string => "includes $(name) previously defined" ,
               policy=>variable;

     # Vectors and lists

     "list2"   int => { "1","2", function("3") };

     "users"   string => { "mark", 
                           "aeleen", 
                           "kyrre", 
                           "matt" } ,

                policy => constant;

     # Associative arrays

     "array1"   string => ReadArray("");

     # Graph

     "Neighbour[fromhost]" string => "tohost";
     "Adj[tohost]"         string => "nexthost";


   # we need a name for variables + classes together

   # sub environments? sub contexts? conduits

   subcontracts:

     "alias1"   bundle => StartProcesses("$(Pservicelist)","on") ,
                transaction => commontrans ,
                usevars => usepolicy();

     "alias2"   bundle => DoProcesses("$(Mservicelist)","off") ,
                transaction => commontrans ,
                usevars => usepolicy();

   processes:

     "$(procs[i])" restart => "$(restart[i])" ;

         # restart has to refer to an executable rule for the same object

     "$(stop[list])" signal => { "stop" , "term" };

   }


##############################################################################

bundle agent main()
   {
   classes:

     "alias1"  or  =>  { "class1", "class2", "class3" };
     "alias2"  or  =>  { class1, class2, class3 };
     "alias3"  and =>  { class1, class2, class3 };

     "alias"   expression =>  "solaris&x86|linux|mac";

     "excess"  expression => IsGreaterThan("$(loadavg)","3");

   vars:

      "x" string => "1,2,3";

   files:

      "/path/file.*"  

            edit_line => myedit("${this}") ,
            access => myaccess;

     ##############################################
     # foreach filelist, foreach myusers
     ##############################################

      "$(filelist)"

           edit_xml => insertfilelist("$(filelist)") ,
           edit_line => diddle ,
           access => myaccess ,
           access => others; # ("white");

   ###############################################################

   subcontracts:    # was methods()

    fromhost|tohost|region::

      "outsource1" # this bundle is the object promising to use the result

         bundle =>  InstallUser("$(users)","$(home[$(users)])", GetPrivData("$(users)") ) ,
         useclasses => any() ,
         usevars => any ,
         server => "mark@$(server[$(host)])";

   ################################################################

   executables: # these are local and trusted, and might change objects that
                # are otherwise promised, so this should exec first

     # There is no use promise here

   process_restart::

     "/script/command"   

        args         => "-d -v -t" ,
        containment  => sandbox ,
        module       => "true";

   ###############################################################

   alerts:

     "Alert Message X"  transaction => filters;

      excess::
  
        "Exceeded resources";

   }

#########################################################

bundle agent Update()

{
vars:

}

#########################################################

bundle server main()

{
vars:

  "portnumber" int => "5803";

  "ok" ipv4_string => { "128.39.89.1/24", "192.1.168.1/24" };

connections:

  "$(portnumber)"  connect=>conpolicy;

 # Key revocation can simply be by timeout, date tidying

fileserve:

  "/file/object"  admit=>listbody , deny=>listbody , privilege=>true;

dbserve:

  "name,key" admit=>listbody , deny=>listbody , privilege=>true;

}

#########################################################

body connect conpolicy

{
TrustKeysFrom => "$(ok)";
AllowConnectionsFrom => "$(ok)";

# allow_all_from => "$(ok)";
}

#########################################################
# The issue with editfiles is that the attributes
# have internal structure - compplex language
# This means that we need sub-types in promsies
#

# Need promises to make bundles of promises to write
# grammatical structures, patterns. This is not needed for
# servers as it only applies to OPERATORS
#########################################################

bundle edit_line myedit(filename)
   {
   classes:

     "mdef" expression => UserDefined("mark");

   vars:

     "new_value" string => "replacement text using $(filename)";

   AppendIfNoLineMatching:

       "My important line.*" 

            data => "New important line" ,
            transaction => controlbody;

   AppendIfNoSuchLine:

      "This a line in $(filename)" ;
   
   Replace:

    classes::

        "string.[abc]*" 

            with => "$(new_value)" ,
            policy => all ,
            define=>afterX;  # trigger ordering

   }

#########################################################


body access others(parame)

{
milkyway::

owner => { "root", "wheel", "sudo" };
}

#########################################################

body access myaccess()

{
any::

  mode => "+077,-02";
  owner => { "mark","siri" };

solaris::

  group => ReadStringList("filename");

linux::

  group => { "root", "wheel" };
}

