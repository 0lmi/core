\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{NewLogo} 


@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************
@c %** start of header
@setfilename cf2-begin-linux.info
@settitle Cfengine Language Fundamentals (Unix)
@setchapternewpage odd
@c %** end of header

@titlepage
@title Cfengine Language Fundamentals (Unix)
@subtitle 
@author cfengine AS

@c @smallbook
     
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2008 Cfengine AS

@end titlepage

@c *************************** File begins here ************************

@ifinfo
@dircategory Cfengine Language Fundamentals
@direntry
* Cfengine Language Fundamentals:
                        
@end direntry
@end ifinfo

@ifnottex
@node Top, Declarative language for Unix-like systems, (dir), (dir)
@top  Cfengine Language Fundamentals
@end ifnottex


@ifhtml
@html
<a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>

<h2>Summary of contents</h2>

@end html
@end ifhtml

@c **********************************************************************
@c CHAPTER
@c **********************************************************************

@menu
* Declarative language for Unix-like systems::  
* Beginners self-test::         
@end menu

@node Declarative language for Unix-like systems, Beginners self-test, Top, Top
@chapter Declarative language for Unix-like systems

Cfengine is a program meant to automate the job of system
administrators. Instead of writing ad hoc custom scripts, cfengine
gives you the easy way of expressing the solution with a simple and
straight forward declarative language. The declarative language allows
you to specify a policy for cfengine to implement. For example as a
policy, an administrator may want @file{tmp} directory to be emptied every
three days, may want the password file to always have the permission
@code{644}, ensure that Apache is up all the time etc.  Policies such as
these and many more can easily be written for cfengine to implement. A
simple code such as:

@smallexample

files:
 /etc/passwd  owner=root mode=644 checksum=md5 action=fixall 

@end smallexample
@noindent will enable cfengine to implement a password file policy without any complex script. 
Cfengine makes the policy implementation easy and simple. 

@c ---------------------------------------------------------

@menu
* First Program for Unix::      
* Installation on Unix::        
* The structure of cfengine declarative language::  
* Sequence vs Order Unix::      
* Using Variables in cfengine 2 Unix::  
* Input-output Unix::           
* Escape sequence::             
* Selection or Classes::        
* Logical Operators and classes Unix::  
* User Defined Classes::        
* File and log rotation::       
* List and Array::              
* Recursion::                   
* Methods::                     
* Cfengine built in methods::   
* List and methods::            
@end menu

@node First Program for Unix, Installation on Unix, Declarative language for Unix-like systems, Declarative language for Unix-like systems
@section First Program for Unix

@menu
* Cfengine components::         
@end menu

@node Cfengine components,  , First Program for Unix, First Program for Unix
@subsection Cfengine components

Cfengine has a number of components constituting the software. They
are @code{cfagent}, @code{cfexecd}, @code{cfservd}, @code{cfenvd},
@code{cfkey}, @code{cfshow}, @code{cfenvgraph} and @code{cfrun}.

@itemize @bullet
@item 
@code{cfagent} is the most important component of cfengine software. It is
the robot that interprets the user policy and implements it in a
convergent manner.
@item
@code{cfexecd} is the component that can schedule the execution of cfengine
and inform the administrator about the results of the execution via
email.
@item
@code{cfservd} is the server daemon component. It is responsible only two
operations, remote copy and execution. This means you don’t need
cfservd to enable cfengine work. It is only becomes necessary when
remote copy and execution are concerned.
@item
@code{cfenvd} is used to collect statistical data about resource usage on
each for anomaly detection.
@item
@code{cfkey} is for public and private key generation.
@item
@code{cfshow} converts the cfengine database into ASCII  format and dump it in a file.
@item
@code{cfenvgraph} formats the @code{cfenvd} database in a form that can be plotted.
@item
@code{cfrun} allows you to request the execution of cfengine on remote hosts.
@end itemize

In this document we will first concentrate on how to use
@code{cfagent} to implement simple policies.

@node Installation on Unix, The structure of cfengine declarative language, First Program for Unix, Declarative language for Unix-like systems
@section Installation on Unix

To install cfengine you need the following software packages
@smallexample
# install

Flex
Bison
Berkeley db
Cfengine software

# compile

tar cfengine-2.2.8.tar
cd cfengine-2.2.8
./configure
make
make install

@end smallexample

@noindent By default cfengine executables are placed in @file{/usr/local/sbin}.


@c ---------------------------------------------------------

@node The structure of cfengine declarative language, Sequence vs Order Unix, Installation on Unix, Declarative language for Unix-like systems
@section The structure of cfengine declarative language

The general structure of cfengine's declarative language is given below:
@smallexample

control:

 variable_1 = ( value1 value2 ... )
 variable_2 = ( value1 value2 ... )
 ...
 variable_n = ( value1 value2 ... )

type_stanza_1: 

  [@var{condition or class}]::
   
    target  attribute1=value1 attribue2=value2 ...

type_stanza_2:

  [@var{condition or class}]::
  
    target attribute1=value1 attribue2=value2 ...

@end smallexample

The control stanza is a special stanza where all the variables
that will be used in the policy file are defined. The control is also
used to specify the order of execution, access control
etc. @code{variable1}, @code{variable2} are variable names. Some variables are
reserved or predefined and some are user-defined variables. The values
of the variable are specified in the parentheses.

The stanzas defines the rule type, for example @code{files} rule type,
@code{disk} rule type etc. Each stanza has an optional condition for
which the policy should be implemented. The condition or class (in
cfengine parlance) must be followed by double colon.
 
Within every stanza or rule type we have attributes or options and
values. Usually, such attributes are defined by cfengine. However, one
can also define new class attributes using the cfengine "defined"
keyword. For example the simple files stanza can have the following
attributes or options: owner, mode, checksum, action etc

The values of the attributes are either predefined or user
defined. For example the value for the action attribute, @code{fixall}, is
predefined but the value for the mode attribute @code{644} is user supplied.

We also have the target which specifies the object we want to apply
the policy. A target is usually a file or a directory. The combination
of target, options and value defines a policy.

In summary cfengine declarative language consist of
@itemize @bullet
@item
One special rule type called @code{control}.
@item
Variables and values.
@item
Rule types or stanzas.
@item
Classes or conditions.
@item
Policies or rules.
@end itemize

@c ----------------------------------------------------
@menu
* Beginner example 1 Unix::     
* Beginner example 2 Unix::     
@end menu

@node Beginner example 1 Unix, Beginner example 2 Unix, The structure of cfengine declarative language, The structure of cfengine declarative language
@subsection Beginner example 1 (Unix)

We are going to test cfengine with simple files rule type example. We
will check if a file has mode 644 if not we change it to 644

@smallexample
#cf_ex1.conf

control:
 actionsequence = ( files )

files:
 /home/linux/cfengineDoc/testfile mode=644 action=fixall

#end

@end smallexample

This policy specification asks cfengine to check if the target
(@file{testfile}) has permission 644, if not cfengine will change the
permission to @code{644}. This check can be done every minute, hour depending
on what you want. It will automate the administrator's job.

We have to run cfagent to test if this policy will be implemented. We
first have to create the file testfile and change the permission to
maybe @code{777}. i.e @code{chmod 777 /home/linux/cfengineDoc/testfile}.

Now create a file called @file{cf_ex1.conf} and type in the file the
policy in example 1. Enter the directory that contains
@file{cf_ex1.conf} and execute the following command.
 
@smallexample

/usr/local/sbin/cfagent -vKf ./cf_ex1.conf

@end smallexample

Thus after the policy is written the cfagent robot is used to implement or run the policy specifications.

@noindent @file{/usr/local/sbin/cfagent} is where the cfengine agent is located and @code{-v}
is for verbose output, @code{-K} is a command to force the immediate implementation of
policy and @code{-f} is used to specify the file which contains the policy
configuration. The policy configuration file is found in
@file{cf_ex1.conf}. By default cfagent runs every 1 minute and if that time
is not elapsed since the last run the current configuration will not
be executed so K option is used to override this default behavior.

In example 1 the actionsequence variable (directive or command) has
the value @code{files}. The value of the actionsequenece variable is placed
in parentheses. There should a space before and after the variable
value like this: @code{( files )}. 

The values of actionsequance represents the rule type and the sequence
of execution. The sequence of execution is simply first come first
serve. E.g actionsequenece = ( files shellcommands ) means the files
command must be executed before the shellcommnds. The files stanza or
rule type has the target @file{testfile} (the full path of the file
should be specified) and attributes or options of the files are mode
and action and the values are @code{644} and @code{fixall} respectively.

@c -------------------------------------------------------------------
@node Beginner example 2 Unix,  , Beginner example 1 Unix, The structure of cfengine declarative language
@subsection Beginner example 2 (Unix)

This example adds a shellcommand to example 1 and executes it from cfengine

@smallexample
#cf_ex2.conf

control:

 actionsequence = ( files shellcommands )

files:

 /home/linux/cfengineDoc/testfile mode=u+rxw action=fixall

shellcommands:

  "/bin/echo ...second cfengine script ..."

#end

@end smallexample



@c ---------------------------------------------------------------------
@node  Sequence vs Order Unix, Using Variables in cfengine 2 Unix, The structure of cfengine declarative language, Declarative language for Unix-like systems
@section Sequenece vs ordering

The order in which you write the rule types in cfengine doesn't always affect
the sequence of execution. For example, example 2 can be rewritten as

@smallexample

#cf_ex2a.conf control: actionsequence = ( files shellcommands )
shellcommands: "/bin/echo ...second cfengine script ..."  files:
/home/linux/cfengineDoc/testfile mode=644 action=fixall #end

@end smallexample

The results will be the same. The @code{files} rule type will be executed
first followed by @code{shellcommands} since the actionsequence specifies
so. So the bulk sequence is specified by the @code{actionsequence} but the order
of rules does not matter.

@c --------------------------------------------------------------------------
@node Using Variables in cfengine 2 Unix, Input-output Unix, Sequence vs Order Unix, Declarative language for Unix-like systems
@section Using Variables in cfengine 2 (Unix)

Variables allow us to store data in memory for processing. Variables are
declared in cfengine as follows: 

@smallexample 

 name = ( value1, value2 ... )

@end smallexample

The name can be any name that follows the general programming
standard. The name can also be a predefined name to set the value of a
reserved control parameter. Example 3 shows how to
work with cfengine variables.

@c ---------------------------------------------------------------
@menu
* Beginner example 3 Unix::     
* Beginner example 4 Unix::     
@end menu

@node Beginner example 3 Unix, Beginner example 4 Unix, Using Variables in cfengine 2 Unix, Using Variables in cfengine 2 Unix
@subsection Beginner example 3 (Unix)

@smallexample

#cf_ex3.conf

 control:

   actionsequence = ( shellcommands )

    hello = ( "hello cfengine " )  #hello variable

 shellcommands:
 
   "/bin/echo ..$(hello).."

@end smallexample

@noindent This code declares the @code{hello} variable and assigns the value "hello
cfengine". We then use shellcommands stanza to display the value of
the variables. The code @code{$(hello)} shows how cfengine reference
variable. There are two ways of referencing cfengine variables. We can
reference a variable with parenthesis or curly braces. For example
@code{$(hello)} can rewritten as @code{$@{hello@}}.

@c -----------------------------------------------------------------

@node Beginner example 4 Unix,  , Beginner example 3 Unix, Using Variables in cfengine 2 Unix
@subsection Beginner example 4 (Unix)


@smallexample

#cf_ex4.conf

 control:

   actionsequence = ( shellcommands )

    hello = ( "hello cfengine " )  #hello variable

 shellcommands:
 
   "/bin/echo ..$@{hello@}.."

@end smallexample

Example 4 will produce the same result as example 3. The only
difference is that the parenthesis is changed to a curly brace i.e.
@code{$@{hello@}}.


@c -------------------------------
@node Input-output Unix, Escape sequence, Using Variables in cfengine 2 Unix, Declarative language for Unix-like systems
@section Input-output (Unix)

The value of a variable can be specified in the cfengine
configuration file or read from a file. Example 5 reads data from a
file and stores it in a variable.

@menu
* Beginner example 5 Unix::     
@end menu

@node Beginner example 5 Unix,  , Input-output Unix, Input-output Unix
@subsection Beginner example 5 (Unix)

@smallexample

#cf_ex5.conf

 control:

   actionsequence = ( shellcommands )

   data = ( ReadFile(/home/linux/cfengineDoc/data.txt,100) )

 shellcommands:
 
  "/bin/echo ..$(data).."

@end smallexample

This example reads data from the file @code{data.txt} using the cfengine
@code{ReadFile} method. The output is stored in the variable data and the
result displayed by @code{shellcommands}. The @code{ReadFile()} method has two
parameters, the file name and the (maximum) number of characters to be read.






@c ------------------------------------------------------------
@node Escape sequence, Selection or Classes, Input-output Unix, Declarative language for Unix-like systems
@section Escape Sequence

Special keys such as tab, newline etc, can also be represented in
cfengine to format output. The following are the some of the escape
sequence.

@itemize @bullet
@item
@code{cr} - Expands to the carriage-return character.
@item
@code{dblquote} - Expands to a double quote @code{"}.
@item
@code{dollar} - Expands to @code{$}.
@item
@code{lf} - Expands to a line-feed character.
@item 
@code{n} - Expands to a newline character.
@item
@code{quote} - Expands to a single quote @code{'}.
@item
@code{spc} - Expands simply to a single space. This can be used to place spaces in filenames etc.
@item
@code{tab} - Expands to a single tab character. 
@end itemize

@c ---------------------------------------------------------------
@menu
* Beginner example 5a Unix::    
@end menu

@node Beginner example 5a Unix,  , Escape sequence, Escape sequence
@subsection Beginner xample 5a (UNix)

@smallexample

#cf_ex5a.conf

 control:

   actionsequence = ( shellcommands )

 alerts:

   linux::

       "The car cost $(n) $(dollar)20,000 "

@end smallexample

@smallexample

The output will be:
The car cost
$20,000

@end smallexample

@node Selection or Classes, Logical Operators and classes Unix, Escape sequence, Declarative language for Unix-like systems
@section Selection or Classes

Selection or classes allow a program to decide which code to
execute. In cfengine such commands are called classes. There are no @code{if}
statement in cfengine, only classes.  By default cfengine classifies
the system environment and used the results to make decisions. The
classes are Boolean with true or false values. We can see the default
or defined classes by running cfagent @code{-vp} command. You also see the
defined classes when you run cfagent @code{-vf ./filename}. 

@smallexample

Defined Classes = ( 192_168_189 192_168_189_128 32_bit Day16 Hr10
Hr10_Q2 July Min15_20 Min19 Q2 Wednesday Yr2008 any cfengine_2
cfengine_2_2 cfengine_2_2_7 compiled_on_linux_gnu debian
fe80__20c_29ff_fec4_f41c i686 ipv4_192 ipv4_192_168 ipv4_192_168_189
ipv4_192_168_189_128 linux linux_2_6_24_19_generic linux_i686
linux_i686_2_6_24_19_generic
linux_i686_2_6_24_19_generic__1_SMP_Wed_Jun_18_14_43_41_UTC_2008
linux_local lsb_compliant net_iface_eth0 ubuntu ubuntu_8 ubuntu_8_4
ubuntu_hardy undefined_domain )
@end smallexample

Users can also define their own classes to use for decision making.

@c -----------------------------------------------------------------
@menu
* Beginner example 6 Unix::     
* Example 7::                   
@end menu

@node Beginner example 6 Unix, Example 7, Selection or Classes, Selection or Classes
@subsection Beginner example 6 (Unix)

This example displays the message "...cfengine classes in action.." if
the operating system of my system is Linux. Cfengine will check if
@code{linux} is part of the defined classes and displays the message
accordingly.

@smallexample

#cf_ex6.conf

 control:

 alerts:
 
    linux::

       "..cfengine classes in action.."

@end smallexample

We can have two or more classes as shown in example 7

@c --------------------------------------------------------------
 
@node Example 7,  , Beginner example 6 Unix, Selection or Classes
@subsection Example 7

@smallexample
#cf_ex7.conf

 control:
   
 alerts:
 
   linux::
       "..cfengine classes in action..linux"

   SuSE::
        "..cfengine classes in action..suse"

@end smallexample

Cfengine will display only the linux message since there is no @code{SuSE} class in the defined classes above.

@c ------------------------------------------------------------------------
@node Logical Operators and classes Unix, User Defined Classes, Selection or Classes, Declarative language for Unix-like systems
@section Logical Operators and classes (Unix)

Logical operators are use to combine conditional statements or
classes. For example we can check if a distribution is either Ubuntu or SuSE,
the distribution is SuSE and the time is quarter past two and so on.
Cfengine has the following  logical operators:

@itemize @bullet
@item
OR   --- @code{|} or @code{||}.
@item
AND  --- @code{&} or @code{.} (dot).
@item
NOT  --- @code{!}
@item
Grouping ---  @code{( )}
@end itemize


@c ----------------------------------------------------------------
@menu
* Beginner example 8 Unix::     
* Beginner example 9 Unix::     
* Beginner example 10 Unix::    
@end menu

@node Beginner example 8 Unix, Beginner example 9 Unix, Logical Operators and classes Unix, Logical Operators and classes Unix
@subsection Beginner example 8 (Unix)

@smallexample
#cf_ex8.conf

 control:
   
 alerts:
 
    redhat.SuSE::

       "..cfengine classes in action.."
@end smallexample

The output is nothing, as the condition can never be satisfied.

Example 8 shows the combination of two classes @code{redhat} and
@code{SuSE}. @code{redhat.SuSE} means if the distribution is redhat and SuSE display
the "cfengine classes in action". Since a distribution cannot be both
redhat and SuSE the results is nothing.

@c ----------------------------------------------------------
@node Beginner example 9 Unix, Beginner example 10 Unix, Beginner example 8 Unix, Logical Operators and classes Unix
@subsection Beginner example 9 (Unix)

@smallexample
 #cf_ex9.conf

 control:
  
 alerts:

   redhat|SuSE::
  
     "..cfengine classes in action.."
@end smallexample

This means if the distribution is either @code{redhat} or @code{SuSE} display the message. 

@c -------------------------------------------------------------------
@node Beginner example 10 Unix,  , Beginner example 9 Unix, Logical Operators and classes Unix
@subsection Beginner example 10 (Unix)

@smallexample

#cf_ex10.conf

 control:
  
 alerts:

    !redhat|Hr10::

       "..cfengine classes in action.."
@end smallexample
 
This means if distribution is not @code{redhat} or the hour is 10am display the results.


@c ---------------------------------------------------------------------
@node User Defined Classes, File and log rotation, Logical Operators and classes Unix, Declarative language for Unix-like systems
@section User Define Classes

It is possible to define your own class using the define keyword or classes rule type.

@menu
* Example 11::                  
* Beginner Example 12 Unix::    
* Beginner example 13 Unix::    
* Beginner Example 14::         
@end menu

@node Example 11, Beginner Example 12 Unix, User Defined Classes, User Defined Classes
@subsection Example 11

@smallexample

#cf_ex11.conf   User define classes and sequence

control:

 classes:
  
    Check = ( FileExists(/home/linux/cf) )

alerts:

   Check::

      "yes"
@end smallexample

This example defines the class @code{Check} using the classes rule type. The
method @code{FileExists()} is cfengine method which check whether or not a
file exists. The value of the class @code{Check} is true if the file @file{cf} is
found in @file{/home/linux} directory. The output of the policy will be `yes'
if the file is found.

@c --------------------------------------------------------------
@node Beginner Example 12 Unix, Beginner example 13 Unix, Example 11, User Defined Classes
@subsection Beginner Example 12 (Unix)

Sometimes you may want cfengine to be aware of your user defined class
before it is used. We do this by using the @code{AddInstallable} method.

@smallexample
#cf_ex12.conf   User define classes and sequence

control:

  #add class that might become define at run time
  AddInstallable = ( Check )

classes:

  Check = ( FileExists(/home/linux/cf) )

alerts:

   Check::
    "yes"
@end smallexample

@c -------------------------------------------------------------------
@node Beginner example 13 Unix, Beginner Example 14, Beginner Example 12 Unix, User Defined Classes
@subsection Beginner example 13 (Unix)

User defined classes can be define at runtime. Example 13 shows how
this is done

@smallexample

#cf_ex13.conf
#User define classes and sequence

control:
    actionsequence = ( files )
    #add class that might become define at run time
    #the order of usage is not important
    AddInstallable  = ( RCheck )

files:
  RCheck::   #RCheck is true
    /home/linux/cfengineDoc/test mode=700 action=fixall

files:
     #define stores the outcome of execution
     #if mode is not 777 then change to 777 and set RCheck to true
 
    /home/linux/cfengineDoc/test1 mode=777 action=fixall define=RCheck
@end smallexample

This example uses the outcome of results in the second stanza (@file{test1})
to fix the file permission for the @file{test} file. The entire policy
reads like this, if the file permission for @file{test1} file is not @code{777}
and the action is taken to change it to @code{777} then change the permission
of the @file{test} file to @code{700}. The order is not important; the right
instruction will be executed.


@c --------------------------------------------------------------
@node Beginner Example 14,  , Beginner example 13 Unix, User Defined Classes
@subsection Beginner Example 14 (Unix)

@smallexample
#User define classes 
control:
  #add class that might become define at run time
   actionsequence = ( files )
   AddInstallable = ( WinXP Indigo )

files:

 Indigo::

   /usr/etc/resolv.conf owner=root action=warn

classes:
  #list of classes of pcs
  WinXP  = ( pc121 pc122 linux )

  #-box2 and -box4 not part
  Indigo  = ( irix -box2 -box4 )

 #if file exist

  RCheck = ( FileExists(/home/linux/cfengineDoc/sequence) )

files:

     RCheck.WinXP:: 
     /home/linux/cfengineDoc/test mode=600 action=fixall
@end smallexample



@c ------------------------------------------------------------------
@node File and log rotation, List and Array, User Defined Classes, Declarative language for Unix-like systems
@section File and log rotation

An example of a useful maintenance procedure which prevents system
failure is log rotation.  We can do this task by using the @code{disable}
stanza. Disabling a file means renaming it so that it becomes
harmless. This feature is useful if you want to prevent certain
dangerous files from being around, but you don't want to delete them 
— a deleted file cannot be examined later. The main syntax is


@smallexample

    disable:
       class::
          /filename
             dest=filename
	     type=plain/file/link/links
	     rotate=empty/truncate/numerical-value
	     size=numerical-value
	     define=classlist

@end smallexample

If a destination filename is specified, cfagent renames the source
file to the destination, where possible (renaming across filesystems
is not allowed). If no destination is given, cfagent renames a given
file by appending the name of the file with the suffix
@file{.cfdisabled}. Note that directories are only renamed if they have a
specific destination specified.

A typical example of a file you would probably want to disable would
be the @file{/etc/hosts.equiv} file which is often found with the
@samp{+} symbol written in it, opening the system concerned to the
entire NIS universe without password protection! Here is an example:


@c --------------------------------------------------------------
@menu
* Beginner Example 16::         
@end menu

@node Beginner Example 16,  , File and log rotation, File and log rotation
@subsection Beginner Example 16 (Unix)

@smallexample
	     disable:
	           /etc/hosts.equiv
	           /etc/nologin
	           /usr/lib/sendmail.fc

             sun4::
	           /var/spool/cron/at.allow

@end smallexample

@noindent Disabling a link deletes the link. If you wish you may use the optional syntax
@smallexample
	     disable:
	         /directory/name type=file
@end smallexample

@noindent in order to specify that a file object should only be disabled if it is a plain
file. The optional element type= can take the values plain, file, link
or links. If one of these is specified, cfengine checks the type and
only disables the object if there is a match. This allows you to
disable a file and replace it by a link to another file for
instance. NOTE that if you regularly disable a file which then gets
recreated by some process, the disabled file filename. cfdisabled will
be overwritten each time cfengine disables the file and therefore the
contents of the original are lost each time. The rotate facility was
created for just this contingency. The disable feature can be used to
control the size of system log files, such as @file{/var/adm/messages}
using a further option rotate. If the value rotate is set to 4, say,
@smallexample
	      disable:
	         filename  rotate=4
@end smallexample

@noindent then cfengine renames the file concerned by appending `.1' to it and a
new, empty file is created in its place with the same owner and
permissions. The next time disable is executed `.1' is renamed to `.2'
and the file is renamed `.1' and a new empty file is created with the
same permissions. Cfengine continues to rotate the files like this
keeping a maximum of four files. This is similar to the behaviour of
syslog.  If you simply want to empty the contents of a log file,
without retaining a copy then you can use rotate=empty or
rotate=truncate. For instance, to keep control of your World Wide Web
server logs:
@smallexample

   disable:
       Sunday|Wednesday::
           /usr/local/httpd/logs/access_log  rotate=empty
@end smallexample

This keeps a running log which is emptied each Sunday and
Wednesday. The size= option in disable allows you to carry out a
disable operation only if the size of the file is less than, equal to
or greater than some specified size. Sizes are in bytes by default,
but may also be quoted in kilobytes or megabytes using the notation:

@smallexample
	     numberbytes
	     numberkbytes
	     numbermbytes
@end smallexample
Only the first characters of these strings are significant, so they
may be written however is convenient: e.g. 14kB, 14k, 14kilobytes
etc. Examples are:

@smallexample	        
                size=<400  # disable if file size is < 400 bytes
	        size=400   # disable if file size is equal to 400 bytes
	        size=>400  # disable if file size > 400 bytes
@end smallexample

This options works with rotate or normal disabling; it is just an
extra condition which must be satisfied. If a disable command results
in action being taken by cfengine, an optional list of classes becomes
can be switched on with the aid of a statement define=classlist in
order to trigger knock-on actions.  The repository declaration allows
a local override of the Repository variable, on an item by item
basis. If set to “off” or “none” it cancels the value of a global
repository and leaves the disabled file in the same directory.



@c -------------------------------------------------------
@node List and Array, Recursion, File and log rotation, Declarative language for Unix-like systems
@section List and Array

Cfengine list allows you to specify a list of items which can be
treated as a single variables. A list can be any set of names, file
names etc. The example 22 shows how to create a list.


@menu
* Beginner example 22 Unix::    
* Beginner example 23 Unix::    
* Beginner example 23a Unix::   
@end menu

@node Beginner example 22 Unix, Beginner example 23 Unix, List and Array, List and Array
@subsection Beginner example 22 (Unix)

@smallexample
 control:
   alist = ( "one:two:three:four:five" )

 alerts:
   linux::
     " $(alist)"

@end smallexample

By default a list should be separated by colon. This can be change using the @code{Split} option.
@cindex Split

@node Beginner example 23 Unix, Beginner example 23a Unix, Beginner example 22 Unix, List and Array
@subsection Beginner example 23 (Unix)


@smallexample
control:

   Split = ( , )

   alist = ( "one,two,three,four,five" )

alerts:
 
 linux::

   " $(alist)"
@end smallexample

The @code{Split} allows us to change the default colon to comma. 

@smallexample
control:

  Split = ( " " )
  mylist = ( "mark ricky bad-dude" )

tidy:
  
  /mnt/home1/$(mylist) pattern=*.cfsaved age=1

@end smallexample


@c -----------------------------------------------------
@node Beginner example 23a Unix,  , Beginner example 23 Unix, List and Array
@subsection Beginner example 23a (Unix)


@smallexample

control:

  Split = ( , )
  alist = ( "one,two,three,four,five" )

alerts:

 redhat::

   " $(alist)"
@end smallexample

Example 23b:
@smallexample

control:
   Split = ( " " )
   mylist = ( "mark ricky bad-dude" )
tidy:
   /linux/home/$(mylist) pattern=*.cfsaved age=1
@end smallexample

In this example cfengine will iterate and substitute mylist with each
of the elements of in the list. It will then delete all @file{.cfsaved} file
which is a day old in each of the directory.

The power of lists is made clear when supplied as a parameter to a
method (see below).








@c -----------------------------------------------------------------------
@node Recursion, Methods, List and Array, Declarative language for Unix-like systems
@section Recursion

Recursion is used to iterate over a directory of files and
subdirectories. The keyword for recursion is @code{recurse} (from the
anonymous saying: to iterate is human, to recurse is divine). The
value of recurse is from @code{0} to @code{inf} (infinity). Where 0
means only current directory container, 1 includes the files in the
current directory and infinity means everything in the directory
including subdirectories.

@c ------------------------------------------------------------------
@menu
* Beginner example 23c Unix::   
@end menu

@node Beginner example 23c Unix,  , Recursion, Recursion
@subsection Beginner example 23c (Unix)

@smallexample

control:

 actionsequence = ( files )

files:

 /home/linux/cfengineDoc mode=644 action=fixall recurse=inf

@end smallexample

@noindent This example means change the mode of everything in the directory @file{cfengineDoc} to @code{644}.
@smallexample

control:

 actionsequence = ( files )

files:

 /home/linux/cfengineDoc mode=644 action=fixall recurse=2

@end smallexample

@noindent This example means change the mode of directory and subdirectory to @code{644}.

@c ------------------------------------------------------------------
@node Methods, Cfengine built in methods, Recursion, Declarative language for Unix-like systems
@section Methods

A method is a set of instructions that achieve a specific task. It is
possible to encapsulate tasks using cfengine methods. Methods in cfengine
are defined as ordinary cfengine configuration files with some extra
control information:

@smallexample
control

 MethodName = ( @var{name} )
 MethodParameters = ( @var{p1 p2 ...} )

 @var{method-body} ...

@end smallexample

The @code{MethodName} directive is use to specify the method name and the
MethodParameters specifies the parameters. The number of parameters
can zero or more. The method body is the usual cfengine policy
code. It is not different from what we know so far. We begin with a
simple method that displays a message.

@c ---------------------------------------------
@menu
* Beginner example 14 Unix::    
* Beginner example 15 Unix::    
* Beginner example 16 Unix::    
* Beginner example 17 Unix::    
* Method and return value::     
* Beginner example 18 Unix::    
* Beginner example 19 Unix::    
* Beginner example 20 Unix::    
@end menu

@node Beginner example 14 Unix, Beginner example 15 Unix, Methods, Methods
@subsection Beginner example 14 (Unix)

@smallexample

#cf_ex14.conf   User define classes and sequence

control:

  MethodName = ( UserClass )

classes:

  Check = ( FileExists(/home/linux/cf) )

alerts:

   Check::
    "Yes the cf exist"

  !Check::
     "No, cf does not exist"

@end smallexample

@noindent This method checks if the file cf exist and display a message. The
method is called @code{UserClass} and has no parameter. In cfengine it is
required that a method is placed in a special directory called
modules. The default location of this directory is @file{/var/cfengine}. So
if you install cfengine with default dicrectory then you must copy the
file @file{cf_ex14.conf} into it @file{/var/cfengine/modules} directory. The next
step is to create a method call configuration file to make use of the
method as in example 14.

@c ----------------------------------------------------
@node Beginner example 15 Unix, Beginner example 16 Unix, Beginner example 14 Unix, Methods
@subsection Beginner example 15 (Unix)

@smallexample

#cf_ex15.conf

control:
 
  actionsequence = ( methods )

methods:

  UserClass(void)
    action=cf_ex14.conf #include the method here
    returnvars=null  #no return value
    server=localhost #run the method on local machine

@end smallexample

Example 15 is the method call's configuration file. The method call has
the @code{methods} rule type. It is used to call the method. Under methods
rule type we call the method by name. Since our method has no
parameters we supply void as parameter entry. The @code{action} directive now
specifies which file contains the method. The @code{returnvars} allows the
return value to be store and reuse it later. Our method has no return
type so the value of return type is null. The server attribute or
option allows you to specify which host will run the method. Here we
chose localhost.

The next example shows how to use parameter in methods. 

@node Beginner example 16 Unix, Beginner example 17 Unix, Beginner example 15 Unix, Methods
@subsection Beginner example 16 (Unix)

@smallexample

#cf_ex16.conf   User define classes and sequence

control:

  MethodName = ( UserClass )
  MethodParameters = ( filename )
     #add class that might become define at run time
      AddInstallable = ( Check )
classes:
  
  Check = ( FileExists("/home/linux/$(filename)") )

alerts:

   Check::
    "Yes the cf exists"
  !Check::
     "No, cf does not exists"

@end smallexample

This method performs the same task as example 15 however the file name
will not be fix but vary. The name will now be supplied at method
call. Example 17 is the method call for example 16. Note that the file
path is in double quote.

@c ---------------------------
@node Beginner example 17 Unix, Method and return value, Beginner example 16 Unix, Methods
@subsection Beginner example 17 (Unix)

@smallexample

control:

 actionsequence = ( methods )

methods:

 UserClass(cf)

   action=cf_ex16.conf
   returnvars=null
   server=localhost

@end smallexample

This example calls the method @code{UserClass} and supply the parameter
cf. The cf will replace the variable or parameter @file{filename} so that
the file path checked will be @file{/home/linux/cf}. As usual the action option
specifies the file which contains the method. The method file must be
located in the modules directory. Note that the method call
configuration file should not be in the modules directory, but in the usual
inputs directory.

@c --------------------------------------------
@node Method and return value, Beginner example 18 Unix, Beginner example 17 Unix, Methods
@subsection Method and return value

A method can return a value which could be used for further
operation. In this case the return value will not be null. Example 18
illustrates how this could be done.

@c ----------------------------------------------------
@node Beginner example 18 Unix, Beginner example 19 Unix, Method and return value, Methods
@subsection Beginner example 18 (Unix)

@smallexample
#cf_ex18.conf   User define classes and sequence

control:

   MethodName = ( ReturnName )
  MethodParameters = ( filename )

classes:
   every = ( any )

alerts:
  every::
   ReturnVariables("$(filename)")

@end smallexample

This method just accepts a file name and returns the same name. The
@code{alerts} rule type is needed to return the results. The method call for
example 18 is shown below.

@c ----------------------------------------
@node Beginner example 19 Unix, Beginner example 20 Unix, Beginner example 18 Unix, Methods
@subsection Beginner example 19 (Unix)

@smallexample

control:

  actionsequence = ( methods )

methods:

  ReturnName(cf)
    action=cf_ex18.conf
    returnvars=results
    server=localhost

classes:
   every = ( any )

alerts:

  every::

   "The file name is $(ReturnName.results)"

@end smallexample

Here the @code{returnvars} value is results. This means the file name being
returned by the method will be stored in the variable results. We then
use the alerts command to display the file name. The results variable
is accessed using the name of the method name.

@c -----------------------------------
@node Beginner example 20 Unix,  , Beginner example 19 Unix, Methods
@subsection Beginner example 20 (Unix)

This example shows how to use more than one parameters in cfengine method.
@smallexample
#cf_ex20.conf   User define classes and sequence

control:

  actionsequence = ( editfiles )
  MethodName = ( EditMethod )
  MethodParameters = ( filename data )

editfiles:

 @{ /home/linux/$(filename)
    
 AppendIfNoSuchLine "$(data)"
 @}

classes:
   every = ( any )

alerts:
  every::
   ReturnVariables("The file name is $(filename) and was editted with $(data)")
@end smallexample

Example 21 calls the method in example 20.

@smallexample
#Example 21

control:
 actionsequence = ( methods )

methods:

 EditMethod(cf,"insert data here")
   action=cf_ex20.conf
   returnvars=results
   server=localhost

classes:
   every = ( any )

alerts:
   every::
     "The file name is $(EditMethod.results)"

@end smallexample

@node Cfengine built in methods, List and methods, Methods, Declarative language for Unix-like systems
@section Cfengine built in methods

Cfengine provides a number of built-in functions for evaluating
classes, based on file tests and perform other functions. Using these
built-in functions is quicker than calling the shell test function.
@table @samp
@item AccessedBefore(f1,f2)
    True if file 1 was accessed more recently than file 2 (UNIX atime)
@item ChangedBefore(f1,f2)
    True if file 1's attributes were changed in any way more recently than file 2's (UNIX ctime)
@item ClassMatch(regexp)
    True if the quoted regular expression matches one of the currently defined classes. It is wise to place ClassMatch at the end of your parsing in order to capture as many of the user-defined classes as possible.
              classes:       
                 userdef = ( ClassMatch(.*linux.*) )       
@item FileExists(file)
    True if the named file object (file/directory or link) exists.
@item GroupExists(groupname|gid)
    True if the groupname or group id is registered on the system.
@item HostRange(basename,start-stop)
    True if the current relative domain name begins with basename and ends with an integer between start and stop. Note well: matching is case insensitive (both hostname and basename are converted to all lower case for comparison.)
@item IsDefined(variable-id)
    True if the named variable is defined. Note well: use the variable name, not its contents (that is, @code{IsDefined(var)}, and not @code{IsDefined($@{var@})})
@item IsDir(f)
    True if the file f is a directory
@item IsLink(f)
    True if the file f is a symbolic link
@item IsPlain(f)
    True if the file f is a plain file
@item IsNewerThan(f1,f2)
    True if file 2 was modified more recently than file 1 (UNIX mtime)
@item IPRange(address-range)
    True if the current host lies within the specified IP range
@item PrepModule(module,arg1 arg2...)
    True if the named module exists and can be executed. The module is
assumed to follow the standard programming interface for modules (see
Writing plugin modules in tutorial). Unlike actionsequence modules,
these modules are evaluated immediately on parsing. Note that the
module should be specified relative to the authorized module
directory.

@item Regcmp(regexp,string or list separated string)
    True if the string matched the regular expression regexp.
ReturnsZero(command)
    True if the named shell command returns with exit code zero (success). The command is executed without a shell wrapper.

@item ReturnsZeroShell(command)
    True if the named shell command returns with exit code zero (success) when executed in the environment of a shell wrapper.

@item Strcmp(s1,s2)
    True if the string s1 exactly matches s2

@item UserExists(username|uid)
    True if the username or user id is registered on the system (this does not imply that the user can log in or has a home directory).

@item IsGreaterThan(s1,s2)
    Returns true if the value of s1 is greater than the value of s2. Note that, if the strings have numerical values, a numerical comparison is performed, otherwise a string comparison is used.

@item IsLessThan(s1,s2)
    Returns true if the value of s1 is less than the value of s2. Note that, if the strings have numerical values, a numerical comparison is performed, otherwise a string comparison is used.
@end table


@c ------------------------------------------------------
@menu
* Beginner example 21 Unix::    
@end menu

@node Beginner example 21 Unix,  , Cfengine built in methods, Cfengine built in methods
@subsection Beginner example 21 (Unix)

@smallexample

 control:
  actionsequence = ( files )
  a = ( 2.12 )
  b = ( 2.11 )
           
classes:
          
  lt = ( IsLessThan($@{a@},$@{b@}) )
  gt = ( IsGreaterThan($@{a@},$@{b@}) )

alerts:

  lt:: "$(a) LESS THAN $(b)"
  gt:: "$(a) GREATER THAN $(b)"

@end smallexample

@table @samp
@item ExecResult(command)
    Executes the named command without a shell-wrapper and inserts the output into the variable. Note that, when this is used in cfengine built-in list variables, any spaces are interpreted as list separators. In other lists, normal rules for iteration apply.
@item ExecShellResult(command)
    Executes the named command with a shell-wrapper and inserts the output into the variable. Note that, when this is used in cfengine built-in list variables, any spaces are interpreted as list separators. In other lists, normal rules for iteration apply.
@item RandomInt(a,b)
    Generate a random integer between a and b.
@item ReadArray(filename,fileformat,separator,comment,Max number of bytes)
    Reads up to a maximum number of bytes from a properly formatted
file into a one-dimensional associated array. File formats are: (i)
@samp{autokey} If this format is specified, ReadArray tries to
interpret the file as a table of items separated with the separator
character. Blank lines and comments (to end of line) are
ignored. Items are keyed numerically starting from 1 to the maximum
number in the file. The newline @code{$(n)} is always considered to be a
separator, no matter what the current separator is.  (ii)
@samp{textkey} If this format is specified, @code{ReadArray} tries to
interpret the file as a list of lines of the form: key,value

@item ReadFile(filename,Max number of bytes)
    Read a maximum number of bytes from a file.

@item ReadTable(filename,fileformat,separator,comment,Max number of bytes)
    Reads up to a maximum number of bytes from a properly formatted file into a two-dimensional associated array.
    (i) @samp{autokey}
        If this format is specified, ReadArray tries to interpret the file as a table of items separated with the separator character. Blank lines and comments (to end of line) are ignored. Items are keyed numerically starting from 1 to the maximum number in the file. Any lines that do not contain the correct number of separators cause the function to fail without making any assignment.
    (ii) @samp{textkey}
        If this format is specified, ReadArray tries to interpret the file as a list of lines of the form:
@smallexample
             key1,key2,value1
             key3,key4,value2
@end smallexample
              This variable would then be references as $(table[key1][key2]). 
@item ReadList(filename,fileformat,comment,Max number of bytes)
    Reads up to a maximum number of bytes from a properly formatted file into a listvariable. File formats are:
    lines
        If this format is specified, ReadList tries to interpret the file as a list of items on separate lines. The value returned is a list formatted by the Split character. 
@smallexample
                hosts = ( ReadList(/var/cfengine/inputs/datafile,lines,#,1000) )
@end smallexample

@item ReadTCP(host/IP,portnumber,send string,Max number of bytes)
    Reads up to a maximum number of bytes from a TCP service. Can be used to test whether certain services are responding to queries. It is recommended that this be used primarily to check services running on localhost. Bear in mind that this clause, executed on 100 hosts will produce the effect of a distributed denial of service attack, so the probe should be restricted to a single representative tester-host. For example: 

@end table

@c ------------------------------------------------------
@node List and methods,  , Cfengine built in methods, Declarative language for Unix-like systems
@section List and Methods

What makes cfengine method powerful is the iteration. It is possible iterate over a list using method. When a list is pass to a method cfengine will automatically iterate over the list.

@menu
* Beginner example 24 Unix::    
* Beginner example 25 Unix::    
@end menu

@node Beginner example 24 Unix, Beginner example 25 Unix, List and methods, List and methods
@subsection Beginner example 24 (Unix)

@smallexample
#cf_ex24.conf  

control:

  MethodName = ( ReturnName )
  MethodParameters = ( filename )

classes:
   every = ( any )

alerts:

  every::
    ReturnVariables("$(filename)")

@end smallexample

@noindent We call the above method with example 25

@c -----------------------------------------------
@node Beginner example 25 Unix,  , Beginner example 24 Unix, List and methods
@subsection Beginner example 25 (Unix)

@smallexample

control:

  actionsequence = ( methods )
  alist = ( one:two:three:four:five )

methods:

  ReturnName($(alist))
  action=cf_ex24.conf
  returnvars=results
  server=localhost

classes:
  every = ( any )

alerts:
      every::
       "The file name is $(ReturnName.results)"
@end smallexample



@c ----------------------------------------------------------------------

@node Beginners self-test,  , Declarative language for Unix-like systems, Top
@chapter Beginners self-test

@cartouche

@itemize @bullet
@item 
What do we use cfengine classes for 
@item
Name any four rule type
@item
Explain how cfexecd functions
@item
Name and explain various cfengine components
@item
Explain why Cfengine is convergent, scalable, secure, voluntary.
@item
Outline cfengine centralized infrastructure setup
 
@end itemize
@end cartouche




@ifhtml
@html
<a name="Contents">
@end html
@end ifhtml

@contents

@ifhtml
@html
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
@end html
@end ifhtml




@bye

