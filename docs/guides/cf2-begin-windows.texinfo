\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{NewLogo} 

@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************
@c %** start of header
@setfilename cf2-begin-windows.info
@settitle Cfengine Language Fundamentals (Windows)
@setchapternewpage odd
@c %** end of header

@titlepage
@title Cfengine Language Fundamentals (Windows)
@subtitle 
@author cfengine AS

@c @smallbook
    

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2008 Cfengine AS

@end titlepage



@c *************************** File begins here ************************


@ifinfo
@dircategory Cfengine Language Fundamentals
@direntry
* Cfengine Language Fundamentals:
                        
@end direntry
@end ifinfo

@ifnottex
@node Top, Declarative language, (dir), (dir)
@top  Cfengine Language Fundamentals
@end ifnottex


@ifhtml
@html
<a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>

<h2>Summary of contents</h2>

@end html
@end ifhtml

@c **********************************************************************
@c CHAPTER
@c **********************************************************************

@menu
* Declarative language::        
@end menu

@node Declarative language,  , Top, Top
@chapter Declarative language

Cfengine is a program meant to automate the job of system
administrators. Instead of writing adhoc custom scripts, cfengine
gives you the easy way of expressing the solution with simple and
straight forward declarative language. The declarative language allows
you to specify a policy for cfengine to implement. For example as a
policy, an administrator may want tmp directory to be emptied every
three days, may want the password file to always have the permission
644, ensure that apache is up all the time etc.  The policies such as
these and many more can easily be written for cfengine to implement.
For example a simple code such as

@smallexample
files:
 c:\filename  mode=644 checksum=md5 action=fixall
@end smallexample
 
@noindent will enable cfengine to implement a file policy without any complex
script. Cfengine makes the policy implementation easy and simple.

@menu
* Cfengine Components::         
* Installation::                
* The structure of cfengine declarative language::  
* Debugging Cfengine::          
* Sequenece vrs order::         
* Cfengine Variables::          
* Input/output::                
* Escape sequence::             
* Selection or Classes::        
* Logical Operators and classes::  
* User Defined Classes::        
* Multiple Classes::            
* List::                        
* Recursion::                   
* Methods::                     
* Method and return value::     
* Cfengine Built in Methods::   
* List and methods  ::          
@end menu

@node Cfengine Components, Installation, Declarative language, Declarative language
@section Cfengine Components


@itemize @bullet
@item 
Cfagent is the most important component of cfengine software. It is the robot that interpret the user policy and implement it in a convergent manner.
@item
Cfexecd is the component that can schedule the execution of cfengine and inform the administrator about the results of the execution via email.
@item
Cfservd is the server daemon component. It is responsible only two operations, remote copy and execution. This means you don’t need cfservd to enable cfengine work. It is only becomes necessary when remote copy and execution are concerned.
@item
Cfenvd is used to collect statistical data about resource usage on each for anomaly detection.
@item
Cfkey is for public and private key generation.
@item
Cfshow  converts the cfengine database into ASCII  format and dump it in a file.
@item
Cfenvgraph formats the cfenvd database in a form that can be plotted
@item
Cfrun allows remote host to request the execution of cfengine.
@end itemize


As beginners we will first concentrate on how to use cfagent to
implement simple policies since it is the most important component or
agent of the cfengine configuration management software. Don’t rush to
setup client/server configuration since it is not really needed to run
cfengine except for pulling operations. The Cfengine client/server
setup is only for update or copying or pulling of files from cfengine
server to cfengine client. The actual configuration management is done
by cfagent running on a host. By understanding how to run cfengine
configuration script on your local host is more than 60% of what is
required to implement cfengine network environment.

@node Installation, The structure of cfengine declarative language, Cfengine Components, Declarative language
@section Installation
@itemize @bullet
@item
Download the cfengine binary for the windows operating system from cfengine.com website into any directory (c:\user say).
@item
 Unpack the zip file to any directory of your choice ( e.g c:\bin ) to obtain the cfengine binary
@item
 All you need is @file{cygwin1.dll}. You can obtain the
@file{cygwin1.dll} by first installing cygwin on your windows system.
You then have to copy the cygwin1.dll from @file{/usr/bin/cygwin1.dll}
to the directory containing your cfengine binary files or put it in
@file{C:\Windows\System32}. Uninstall cygwin from your system. You don't need
to install cygwin on the rest of your windows systems, you only have
to copy the cygwin1.dll and distribute it with your binary. Please
note that downloading cygwin1.dll directly may not work!!
@item
 Run the cmd DOS command from "Run" or "Start" to the DOS prompt
@item
cd to your cfengine binary directory ( e.g cd bin )
@item
Run the command cfagent -vp, you should see the cfengine hard classes display. The command will also create the c:\var\cfengine directory including the other important cfengine subdirectories such as modules etc.
@item
Now you may copy your cfengine binary into @file{c:\var\cfengine\bin}
including your cygwin1.dll library. By default cfengine runs from
@smallexample
   c:\var\cfengine directory.
@end smallexample

@item
 You should create the cfengine inputs directory in
@file{c:\var\cfengine}. This is where cfengine reads its default
configuration files.
@item
Run the cfkey command to create the cfengine key pairs. This keys will be found in @file{c:\var\cfengine\ppkeys}         
@item
To start using cfengine to manage your system, please read the online tutorial at cfengine.com or cfengine.org
@item
 Note you can decide to use the cygdrive to specify a path to windows
file E.g @file{/cygdrive/c/myfile} means @file{c:\myfile} or you can
do it straight away in cfengine as @file{c:\myfile}.
@item
@end itemize

@node The structure of cfengine declarative language, Debugging Cfengine, Installation, Declarative language
@section The structure of cfengine declarative language

The structure of cfengine declarative language is given below
@smallexample
control:
 variable_1 = ( @var{value1 value2 ...} )
 variable_2 = ( @var{value1 value2 ...} )
...
 variable_n = ( @var{value1 value2 ...} )

 stanza1: 

  [@var{condition or class}]::
   @var{target  attribute1=value1, attribue2=value2 ...}

 stanza2:

  [@var{condition or class}]::
    
    @var{target attribute1=value1, attribue2=value2 ...  }
@end smallexample


The control stanza is a special stanza where all the global variables
that will be used in the policy file are defined. The control could be
used to specify the order of execution, access control etc.

@code{variable1} ... are the variable names, they can be
reserved or predefined variables or user defined variables. The values
of the variable are specified in the parenthesis. The values can be a
stanza or action type, a class or Boolean, a path or any appropriate
user defined value. The stanzas define the rule type or action type,
for example files rule type or action type, disk rule type or action
type etc. 

Each stanza consists of optional condition for which the policy should
be implemented. The condition or class ( as called by cfengine ) must
be followed by double colon.  Within every stanza or rule type (action
type) we have target, attributes or options, values and
action. Usually, such attributes are defined by cfengine. However, one
can define their own attribute using the cfengine "defined"
keyword. For example the simple files stanza can have the following
attributes or options: @code{owner}, @code{mode}, @code{checksum}.

The values of the attributes are either predefined or user
defined. For example the value for the mode attribute @code{644} is user
defined but the value for checksum is @code{md5} which is predefined.  The
target defines the object to which cfengine will manage or operate on.
A target can be a file, a directory, a process etc.  action defines
the operation we want cfengine to perform on a given target. We also
have the target which specifies the object we want to apply the
policy.
 
In summary cfengine declarative language consist of

@itemize @bullet
@item
special rule type called control
@item
varibles and values
@item
rule type, action type or stanza
@item
classes or conditions
@item
policies
@end itemize


Example 1

We are going to test cfengine by simple files rule type example. We
will check if a file has mode @code{644} if not we change it to @code{000}.

@smallexample
#cf_ex1.conf
control:
 actionsequence = ( files )
files:
 /cygdrive/c:/cfengine/testfile.txt mode=000 action=fixall
#end
@end smallexample

This policy specification allows cfengine to check if the target
(@file{testfile.txt}) has permission @code{000}, if not cfengine will change
the permission to @code{000}. This check can be done every minute, hour
depending on what you want. Cfengine will automate the administrator's
job. The permission @code{000} means no one can read, write or execute the
file.

We will run cfagent to test if this policy will be implemented. We
first have to create the file testfile.txt and make it readable,
writable and executable by all. To do that right click the file and go
to properties -> security and change the permissions.  Now create a
file called @file{cf_ex1.conf} and type in the file policy in example 1.
Save the file in @file{c:\var\cfengine\inputs} folder. Cfengine by default
look for all the configurations files from @file{c:\var\cfengine\inputs}.

Type the following command for cfengine to implement the policy:
@smallexample

c:\var\cfengine\bin>cfagent -vKf cf_ex1.conf

@end smallexample

@noindent The directory @file{c:\var\cfengine\bin} is where the cfengine agent is located and @option{-v} 
is for verbose output, @option{-K} is a command to force the
implementation of policy and @option{-f} is used to specify the file
which contains the policy configuration. The policy configuration file
is found in @file{cf_ex1.conf}. By default cfagent runs every 1 minute and if
that time is not elapsed since the last run the current configuration
will not be executed so @option{-K} option is used to override this default
option.  In example 1 the actionsequence variable (directive or
command) has the value files. The value of the actionsequenece
variable is placed in parenthesis. There should be a space before and
after the variable value ( files ). The values of actionsequance
represent the rule type and the sequence of execution. 

The sequence of
execution is simply first come first serve. E.g 
@smallexample
actionsequenece = ( files shellcommands ) 
@end smallexample
@noindent means the files command must be executed before
the shellcommnds. The files stanza or rule type has the target
@file{testfiles.txt} (the full path of the file should be specified)
and attributes or options of the files are mode and action and the
values are 000 and fixall respectively. The action is a special
attribute. It is used to specify operation to be performed or action
to be taken. The cygdrive is more reliable way of specifying cfengine
path. The path @file{/cygdrive/c/cfengine/testfile.txt} will be
interpreted as @file{c:\cfengine\testfiles.txt} in windows.

@c Example 2

This example adds shell commands to example 1 and executes it from cfengine
@smallexample

#cf_ex2.conf
control:
 actionsequence = ( files shellcommands )
 files:
 /cygdrive/c/cfengine/testfile.txt mode=644 action=fixall

shellcommands:
  "/bin/echo ...second cfengine script ..."

@end smallexample

This example shows that cfengine configuration file may contain more
than one action type. The files action type just fix the file
permission of the testfile.txt and the shellcommands action type just
echoes or displays a message `second cfengine script'.


@node Debugging Cfengine, Sequenece vrs order, The structure of cfengine declarative language, Declarative language
@section Debugging Cfengine

This section helps us to understand some simple errors that we may encounter when creating cfengine configuration file. Whenever an error occurs in cfengine configuration files, cfengine will tell which line in the configuration contains the error. Using the –v option in cfagent execution helps us spot the error.

Example 2b

One of the common errors a beginner could make is the space around the actionsequence. In this example we try to remove the space around the action sequence value, files, and examine the response from cfengine. 

@smallexample

#cf_ex2b.conf
control:
 actionsequence = (files)  #no space around the files rule type
files:
 /cygdrive/c/cfengine/testfile.txt mode=000 action=fixall
#end
@end smallexample

Now run the following command
c:\var\cfengine\bin>cfagent -vKf cf_ex1b.conf
 
The message you will see is:
/var/cfengine/inputs/cf_ex1b.conf:2: syntax error

This means you should examine line 2 of the cf_ex1b.conf file. Usually fengine does not suggest the kind of error. As a general rule it is good to always run cfengine with the verbose option. Also any time you have an error cfengine will be able to tell the line number in which the error occurred.


@node Sequenece vrs order, Cfengine Variables, Debugging Cfengine, Declarative language
@section Sequence vrs order

The order in which you write the rule types in cfengine doesn't affect the sequence of execution. For example, example 2 can be rewritten as

@smallexample
#cf_ex2a.conf
control:
 actionsequence = ( files shellcommands )
shellcommands:
  "/bin/echo ...second cfengine script ..."
files:
 /cygdrive/c/cfengine/testfile.txt mode=644 action=fixall
#end
@end smallexample

The results will be the same. The files rule type will be executed first followed by shellcommands since the actionsequence specifies so. So the sequence is specified by the actionsequence but the order of rules does not matter. 


@node Cfengine Variables, Input/output, Sequenece vrs order, Declarative language
@section Cfengine Variables

Variables allow us to store data in memory for processing. It enable a programmer to reference a certain memory location. Variables are declared in cfengine as follows:
name = ( value1, value2 ... )

The name can be any name that follows the general programming standard. The name can also be predefined name. Values are either given or user supplied. A variable can hold one or more data. Example 3 shows how to work with cfengine variables.

@smallexample
Example 3
#cf_ex3.conf
 control:
   actionsequence = ( shellcommands )
    hello = ( "hello cfengine " )  #hello variable
   shellcommands:
   "/bin/echo ..$(hello).."

@end smallexample

This code declares the hello variable and assigns the value "hello
cfengine". We then use shellcommands stanza to display the value of
the variables. The code $(hello) shows how cfengine references
variables. There are two ways of referencing cfengine variables. We
can reference a variable with parenthesis or curly bracket. For
example @code{$(hello)} can be rewritten as @code{$@{hello@}}.

@smallexample

#cf_ex4.conf

 control:
   actionsequence = ( shellcommands )
    hello = ( "hello cfengine " )  #hello variable

 shellcommands:

   "/bin/echo ..$@{hello@}.."

@end smallexample

Example 4 will produce the same result as example 3. The only
difference is that the parenthesis is changed to curly brace i.e.
@code{$@{hello@}}.

@node Input/output, Escape sequence, Cfengine Variables, Declarative language
@section Input/output

The values of a variable can be specified in the cfengine
configuration file or read from a file. Example 5 read data from a
file and stores it in a variable.

@smallexample
Example 5
#cf_ex5.conf
control:
   actionsequence = ( shellcommands )
   data = ( ReadFile(/cygdrive/c/cfengine/data.txt,100) )  #reading from a file

 shellcommands:

   "/bin/echo ..$(data).."

@end smallexample

This example reads data from the file data.txt using the cfengine
ReadFile method. The output is stored in the variable data and the
result displayed by shellcommands. The @code{ReadFile()} method has two
parameters, the file name and the number of characters to be read.

@c -----------------------------------
@node Escape sequence, Selection or Classes, Input/output, Declarative language
@section Escape Sequence


Special keys such as tab, newline etc can also be represented in
cfengine to format output. The following are the some of the escape
sequence.

@table @samp
@item cr
Expands to the carriage-return character.
@item dblquote
Expands to a double quote "
@item dollar
Expands to `$'.
@item lf
Expands to a line-feed character 
@item n
Expands to a newline character.
@item quote
Expands to a single quote '.
@item spc
Expands simply to a single space. This can be used to place spaces in filenames etc.
@item tab
Expands to a single tab character. 
@end table

Example 5a
@smallexample
#cf_ex5a.conf
 
control:
   actionsequence = ( shellcommands )
   
alerts:
   compiled_on_cygwin::
  
     "The car cost $(n) $(dollar)20,000 "

@end smallexample

The output will be:

@smallexample
The car cost
$20,000
@end smallexample

Write a sentence and put it in double quote


@node Selection or Classes, Logical Operators and classes, Escape sequence, Declarative language
@section Selection or Classes

Selection or classes allow a program to decide which code to
execute. In cfengine such commands are called classes. There are no if
statement in cfengine, only classes.  By default cfengine classifies
the system environment and used the results to make decisions. The
classes are Boolean with true or false values. We can see the default
or defined classes by running @code{cfagent -vp} command. My system has the
following define classes

@smallexample
Defined Classes = ( 192_168_157 192_168_157_1 192_168_189 192_168_189_1 32_bit A
ugust Day7 Hr11 Hr11_Q4 IBM Min55_00 Min58 Q4 Thursday Yr2008 any cfengine_2_2 c
fengine_2_2_8 cfengine_2_2_8_pwin compiled_on_cygwin cygwin_nt_6_0_1_5_25_0_156_
4_2_ cygwin_nt_6_0_i686 cygwin_nt_6_0_i686_1_5_25_0_156_4_2_ cygwin_nt_6_0_i686_
1_5_25_0_156_4_2__2008_06_12_19_34 i686 ibm ipv4_192 ipv4_192_168 ipv4_192_168_1
57 ipv4_192_168_157_1 ipv4_192_168_189 ipv4_192_168_189_1 net_iface_eth0 net_ifa
ce_eth1 net_iface_lo nt undefined_domain )
@end smallexample

This means I can use any of these values to make a decision. For example, this configuration

@smallexample
files:
   August::  
/cygdrive/c/cfengine/testfile mode=644 action=fixall
@end smallexample

Means the file operation should be performed if the month is August. Each of the names in the Defined Classes can be used to write a conditional statement. Thus they are meant for decision making. 

Users can also define their own classes which can also be used for decision making.

Example 6
This example displays the message "...cfengine classes in action.."  if the compiled_on_cygwin classes is found on your system. Cfengine will check if " compiled_on_cygwin" is part of the defined classes and displays the message accordingly.

@smallexample
#cf_ex6.conf

control:
   
alerts:

   compiled_on_cygwin::

       "..cfengine classes in action.."
@end smallexample

We can have two or more classes as shown in example 7

@smallexample 
#cf_ex7.conf
 
control:
   
alerts:
   compiled_on_cygwin::

       "..cfengine classes in action..windows"

   SuSe::

        "..cfengine classes in action..suse"

@end smallexample

Cfengine will display only the first message since there is no
@code{SuSE} classes in my defined classes above



@node Logical Operators and classes, User Defined Classes, Selection or Classes, Declarative language
@section Logical Operators and classes

Logical operators are used to combine conditional statements or
classes. For example we can check if a our operating system is windows
or linux, the operating system is windows and the time is quarter pass
two and so on.

Cfengine has the following  logical operators:
@itemize @bullet
@item
OR   --- @samp{|} or @samp{||}
@item
AND  --- @samp{&} or @samp{.} (dot)
@item
Not  --- @samp{!}
@item
Grouping ---  @samp{( )}
@end itemize


@smallexample
Example 8
#cf_ex8.conf
control:

alerts:

  redhat.SuSE::

       "..cfengine classes found.."

@end smallexample

The output is nothing.

Example 8 shows the combination of two classes redhat and
SuSe. redhat.SuSe means if the distribution is redhat and suse display
the "cfengine classes found". Since a distribution cannot be both
redhat and suse or the two classes are not found in the defined
classes above nothing is displayed.

@smallexample
 #cf_ex9.conf
 control:
   alerts:
     compile_on_cygwin|SuSe::
       "..at least on class is found.."
@end smallexample

This means if either of the classes @code{compile_on_cygwin} or
@code{SuSE} if found on the system, display the message.




@smallexample
#cf_ex10.conf
 
control:
   
alerts:

  !redhat|Hr10::

       "..cfengine classes in action.."

@end smallexample
 
This means if distribution is not redhat or the hour is 10 am display the results.

@node User Defined Classes, Multiple Classes, Logical Operators and classes, Declarative language
@section User Defined Classes

It is possible to define your own class using the define keyword or classes rule or action type.

@smallexample
#cf_ex11.conf   User define classes and sequence

control:
 
classes:

  Check = ( FileExists(/cygdrive/c/cfengine/cf.txt) )

alerts:

   Check::
    "yes"

@end smallexample

This example defines the class @code{Check} using the classes rule type. The
method @code{FileExists()} is cfengine method which check whether or not a
file exists. The value of the class @code{Check} is true if the file cf.txt
is found @file{c:\cfengine} in directory. The output of the policy will be
yes if the file is found.


@c Example 12

Sometimes you may want cfengine to be aware of your user defined class
before it is used. We do this by using the AddInstallable method.

@smallexample
#cf_ex12.conf  

control:
     #add class that might become define at run time
      AddInstallable = ( Check )
classes:
  Check = ( FileExists(/cygdrive/c/cfengine/cf.txt) )

alerts:
   Check::
    "yes"
@end smallexample

@c Example 13

User defined classes can be define at runtime. 
@smallexample
#cf_ex13.conf
#User define classes and sequence

control:
    actionsequence = ( files )
    #add class that might become define at run time
    #the order of usage is not important
    AddInstallable  = ( RCheck )

files:

  RCheck::   #RCheck is true

     /cygdrive/c/cfengine/test mode=700 action=fixall

files:
      #define stores the outcome of execution
      #if mode is not 777 then change to 777 and set RCheck to true

      /cygdrive/c/cfengine/test1 mode=777 action=fixall define=RCheck

@end smallexample

This example uses the outcome of results in the second stanza (test1)
to fix the file permission for the @file{test} file. The entire policy
reads like this, if the file permission for @file{test1} file is not @code{777}
and the action is taken to change it to 777 then change the permission
of the @file{test} file to @code{700}. The order is not important; the right
instruction will be executed.


@node Multiple Classes, List, User Defined Classes, Declarative language
@section Multiple Classes

@smallexample
#User define classes 
control:
  #add class that might become define at run time
   actionsequence = ( files )
   AddInstallable = ( WinXP Indigo )

classes:

  #list of classes of pcs
  WinXP  = ( pc121 pc122 linux )
  #-box2 and -box4 not part
  Indigo  = ( irix -box2 -box4 )
 #if file exist

  RCheck = ( FileExists(/cygdrive/c/cfengine/sequence.txt) )

files:

  RCheck.WinXP::   #RCheck and pc121 or RCheck and p122 or RCheck and linux is true

    /cygdrive/c/cfengine/test.txt mode=600 action=fixall

@end smallexample



@node List, Recursion, Multiple Classes, Declarative language
@section List
 
Cfengine list allows you to specify a list of items which can be
treated as a single variable. A list can be any set of names, file
names etc. The example 22 shows how to create a list.

@c Example 22

@smallexample
control:
  alist = ( "one:two:three:four:five" )

alerts:

 compiled_on_cygwin::

  " $(alist)"

@end smallexample

By default a list should be separated by colon. This can be changed using the Split option.

@c Example 23

@smallexample

control:

   Split = ( , )
   alist = ( "one,two,three,four,five" )

alerts:

 compiled_on_cygwin::
  " $(alist)"

@end smallexample

The @code{Split} method allows us to change the default colon to comma. The
power of a list is made clear when it is supplied as a parameter to a
method.

@smallexample
control:
        Split = ( " " )
        mylist = ( "mark ricky bad-dude" )
     
tidy:
        /cygdrive/c/$(mylist) pattern=*.cfsaved age=1

@end smallexample

In this example cfengine will iterate and substitute mylist with each
of the elements of in the list. It will then delete all .cfsaved file
which is a day old in each of the directory.


@node Recursion, Methods, List, Declarative language
@section Recursion

Recursion is used to iterate a directory of files and
subdirectories. The keyword for recursion is recurse. The value of
recurse is from @code{0} to @code{inf} (infinity). Where @code{0}
means stay in the current directory and infinity means everything in
the current directory including subdirectories.

@c Example 24
@smallexample
control:
 actionsequence = ( files )

files:
 /cygdrive/c/cfengineDoc mode=644 action=fixall recurse=inf

@end smallexample

@noindent This example means change the mode of everything in the directory tree to 644.

@c Example 25

@smallexample
control:
 actionsequence = ( files )

files:

  /cygdrive/c/cfengineDoc mode=644 action=fixall recurse=1

@end smallexample

This example means change the mode of current directory and subdirectory to 644.

@c --------------------------------------------
@node Methods, Method and return value, Recursion, Declarative language
@section Methods

A method is a set of instructions that achieve a specific task. It is
possible to perform a task using cfengine method. Methods in cfengine
is given by

@smallexample
control

 MethodName = ( name )
 MethodParameters = ( p1 p2 ... )

  @var{method-body}

@end smallexample

The @code{MethodName} directive is use to specify the method name and the
@code{MethodParameters} specifies the parameters. The number of parameters
can zero or more. The method body is the usual cfengine policy
code. It is not different from what we know so far. We begin with a
simple method that displays a message.

@c Example 26
@smallexample
#cf_ex26.conf   User define classes and sequence
control:

  MethodName = ( UserClass )
  
   #add class that might become define at run time
      AddInstallable = ( Check )

classes:
  Check = ( FileExists(/cygdrive/c/cfengine/cf.txt) )

alerts:
   Check::
    "Yes the cf exist"
  !Check::
     "No, cf does not exist"

@end smallexample

This method checks if the file cf exist and display a message. The
method is called @code{UserClass} and has no parameter. In cfengine it is
required that a method is placed in a special directory called
modules. The default location of this directory is
@file{c:\var\cfengine\modules}. You should copy the @file{cf_ex26.conf} file into
the modules folder. The next step is to create a method call
configuration file to make use of the method as in example 27.


@c Example 27

@smallexample
#cf_ex27.conf

control:
 actionsequence = ( methods )

methods:
  UserClass(void)
  action=cf_ex26.conf #include the method here
  returnvars=null  #no return value
  server=localhost #run the method on local machine

@end smallexample

The method call has the methods rule type. It is used to call the
method. Under methods rule type we call the method by name. Since our
method has no parameters we supply void as parameter entry. The action
directive now specifies which file contains the method. The @code{returnvars}
allows the return value to be store and reuse it later. Our method has
no return type so the value of return type is null. The server
attribute or option allows you to specify which host will run the
method. In this example the local host will run the method.

The next example shows how to use parameter in methods. 

Example 28
@smallexample
#cf_ex28.conf   User define classes and sequence

control:

  MethodName = ( UserClass )
  MethodParameters = ( filename )
  
   #add class that might become define at run time

      AddInstallable = ( Check )

classes:
  Check = ( FileExists("/cygdrive/c/cfengine/$(filename)") )

alerts:
   Check::
    "Yes the cf exists"
  !Check::
     "No, cf does not exists"

@end smallexample

This method performs the same task as example 26 however the file name
will not be fix but vary. The name will now be supplied at method
call. Example 29 is the method call for example 28. Note that the file
path is in double quote.

@c Example 29
@smallexample

control:
 actionsequence = ( methods )

methods:
 UserClass(cf)
 action=cf_ex28.conf
 returnvars=null
 server=localhost

@end smallexample

This example calls the method UserClass and supply the parameter
cf. The cf will replace the variable or parameter @file{filename} so that
the file path will @file{c:\cfengine\cf}. As usual the action option
specifies the file which contains the method. The method file must be
located in the modules directory. Note that the method call
configuration file should not be in the modules directory.


@node Method and return value, Cfengine Built in Methods, Methods, Declarative language
@section Method and return value

A method can return a value which could be used for further
operation. In this case the return value will not be null. Example 30
illustrates how this could be done.

@c Example 30

@smallexample
#cf_ex30.conf   User define classes and sequence

control:
  MethodName = ( ReturnName )
  MethodParameters = ( filename )

classes:

   every = ( any )

alerts:
  every::
   ReturnVariables("$(filename)")

@end smallexample

This method just accepts a file name and returns the name of the
file. The alerts rule type is needed to return the results. The method
call for example 30 is shown below.


@c Example 31

@smallexample

control:
 actionsequence = ( methods )

methods:
 ReturnName(cf)
 action=cf_ex30.conf
 returnvars=results
 server=localhost

classes:
 every = ( any )

alerts:
      every::
       "The file name is $(ReturnName.results)"

@end smallexample

Here the returnvars value is results. This means the file name being
returned by the method will be stored in the variable results. We then
use the alerts command to display the file name. The results variable
is accessed using the name of the method name.  Example 32 This
example shows how to use more than one parameters in cfengine method.


@smallexample
#cf_ex32.conf User define classes and sequence

control:
  actionsequence = ( editfiles )
  MethodName = ( EditMethod )
  MethodParameters = ( filename data )

editfiles:

 @{  /cygdrive/c/cfengine/$(filename)
    AppendIfNoSuchLine
     "$(data)"
 @}

classes:
   every = ( any )

alerts:
  every::
   ReturnVariables("The file name is $(filename) and was editted with $(data)")

@end smallexample

Example 33 calls the method in example 32.

Example 33

@smallexample
control:
 actionsequence = ( methods )
methods:
 EditMethod(cf,"insert data here")
 action=cf_ex32.conf
 returnvars=results
 server=localhost
classes:
 every = ( any )
alerts:
      every::
       "The file name is $(EditMethod.results)"
@end smallexample


@node  Cfengine Built in Methods, List and methods  , Method and return value, Declarative language
@section Cfengine Built in Methods

Cfengine provides a number of built-in functions for evaluating
classes, based on file tests and perform other functions. Using these
built-in functions is quicker than calling the shell test function.

@table @samp
@item AccessedBefore(f1,f2)
    True if file 1 was accessed more recently than file 2 (UNIX atime)
@item ChangedBefore(f1,f2)
    True if file 1's attributes were changed in any way more recently than file 2's (UNIX ctime)
@item ClassMatch(regexp)
    True if the quoted regular expression matches one of the currently defined classes. It is wise to place ClassMatch at the end of your parsing in order to capture as many of the user-defined classes as possible.
@smallexample
              classes:       
                 userdef = ( ClassMatch(.*linux.*) )       
@end smallexample
@item FileExists(file)
    True if the named file object (file/directory or link) exists.
@item GroupExists(groupname|gid)
    True if the groupname or group id is registered on the system.
@item HostRange(basename,start-stop)
    True if the current relative domain name begins with basename and ends with an integer between start and stop. Note well: matching is case insensitive (both hostname and basename are converted to all lower case for comparison.)
@item IsDefined(variable-id)
    True if the named variable is defined. Note well: use the variable name, not its contents (that is, IsDefined(var), and not @code{IsDefined($@{var@})})
@item IsDir(f)
    True if the file f is a directory
@item IsLink(f)
    True if the file f is a symbolic link
@item IsPlain(f)
    True if the file f is a plain file
@item IsNewerThan(f1,f2)
    True if file 2 was modified more recently than file 1 (UNIX mtime)
@item IPRange(address-range)
    True if the current host lies within the specified IP range
@item PrepModule(module,arg1 arg2...)
    True if the named module exists and can be executed. The module is assumed to follow the standard programming interface for modules (see Writing plugin modules in tutorial). Unlike actionsequence modules, these modules are evaluated immediately on parsing. Note that the module should be specified relative to the authorized module directory.

@item Regcmp(regexp,string or list separated string)
    True if the string matched the regular expression regexp.
@item ReturnsZero(command)
    True if the named shell command returns with exit code zero (success). The command is executed without a shell wrapper.
@item ReturnsZeroShell(command)
    True if the named shell command returns with exit code zero (success) when executed in the environment of a shell wrapper.

@item Strcmp(s1,s2)
    True if the string s1 exactly matches s2

@item UserExists(username|uid)
    True if the username or user id is registered on the system (this does not imply that the user can log in or has a home directory).

@item IsGreaterThan(s1,s2)
    Returns true if the value of s1 is greater than the value of s2. Note that, if the strings have numerical values, a numerical comparison is performed, otherwise a string comparison is used.

@item IsLessThan(s1,s2)
    Returns true if the value of s1 is less than the value of s2. Note that, if the strings have numerical values, a numerical comparison is performed, otherwise a string comparison is used.
@end table

@smallexample
Example           

control:

  actionsequence = ( files )
  a = ( 2.12 )
  b = ( 2.11 )
           
classes:      

  lt = ( IsLessThan($@{a@},$@{b@}) )
  gt = ( IsGreaterThan($@{a@},$@{b@}) )

alerts:             
  lt:: "$(a) LESS THAN $(b)"
  gt:: "$(a) GREATER THAN $(b)"

@end smallexample

@table @samp
@item ExecResult(command)
Executes the named command without a shell-wrapper and inserts the output into the variable. Note that, when this is used in cfengine built-in list variables, any spaces are interpreted as list separators. In other lists, normal rules for iteration apply.

@item ExecShellResult(command)
    Executes the named command with a shell-wrapper and inserts the output into the variable. Note that, when this is used in cfengine built-in list variables, any spaces are interpreted as list separators. In other lists, normal rules for iteration apply.

@item RandomInt(a,b)
    Generate a random integer between a and b.

@item ReadArray(filename,fileformat,separator,comment,Max number of bytes)
    Reads up to a maximum number of bytes from a properly formatted file into a one-dimensional associated array. File formats are:
    autokey
        If this format is specified, ReadArray tries to interpret the file as a table of items separated with the separator character. Blank lines and comments (to end of line) are ignored. Items are keyed numerically starting from 1 to the maximum number in the file. The newline $(n) is always considered to be a separator, no matter what the current separator is.
    textkey
        If this format is specified, ReadArray tries to interpret the file as a list of lines of the form:
                         key,value              
@item ReadFile(filename,Max number of bytes)
    Read a maximum number of bytes from a file.
@item ReadTable(filename,fileformat,separator,comment,Max number of bytes)
    Reads up to a maximum number of bytes from a properly formatted file into a two-dimensional associated array.
    autokey
        If this format is specified, ReadArray tries to interpret the file as a table of items separated with the separator character. Blank lines and comments (to end of line) are ignored. Items are keyed numerically starting from 1 to the maximum number in the file. Any lines that do not contain the correct number of separators cause the function to fail without making any assignment.
    textkey
        If this format is specified, ReadArray tries to interpret the file as a list of lines of the form:
                         key1,key2,value1
                         key3,key4,value2
              This variable would then be references as $(table[key1][key2]). 
@item ReadList(filename,fileformat,comment,Max number of bytes)
    Reads up to a maximum number of bytes from a properly formatted file into a listvariable. File formats are:
    lines
        If this format is specified, ReadList tries to interpret the file as a list of items on separate lines. The value returned is a list formatted by the Split character. 
                hosts = ( ReadList(/var/cfengine/inputs/datafile,lines,#,1000) )
   
@item ReadTCP(host/IP,portnumber,send string,Max number of bytes)
    
Reads up to a maximum number of bytes from a TCP service. Can be used
to test whether certain services are responding to queries. It is
recommended that this be used primarily to check services running on
localhost. Bear in mind that this clause, executed on 100 hosts will
produce the effect of a distributed denial of service attack, so the
probe should be restricted to a single representative tester-host. For
example:

@end table



@node List and methods  ,  , Cfengine Built in Methods, Declarative language
@section List and methods

What makes cfengine method powerful is the iteration. It is possible to iterate over a list using method. When a list is passed to a method cfengine will automatically iterate over the list.

Example 34
@smallexample
#cf_ex34.conf  

control:

  MethodName = ( ReturnName )
  MethodParameters = ( filename )

classes:
   every = ( any )

alerts:
  every::
   ReturnVariables("$(filename)")
@end smallexample

We call the above method with example 35

Example 35

@smallexample
control:

 actionsequence = ( methods )
 alist = ( one:two:three:four:five )

methods:

 ReturnName($(alist))
 action=cf_ex24.conf
 returnvars=results
 server=localhost

classes:

 every = ( any )

alerts:

  every::
   "The file name is $(ReturnName.results)"

@end smallexample


@ifhtml
@html
<a name="Contents">
@end html
@end ifhtml

@contents

@ifhtml
@html
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
@end html
@end ifhtml




@bye

