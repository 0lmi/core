\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{NewLogo} 

@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************
@c %** start of header
@setfilename cf2-Packages.info
@settitle Package Management in Cfengine
@setchapternewpage odd
@c %** end of header

@titlepage
@title Package Management in Cfengine
@subtitle A cfengine AS workbook
@author cfengine AS

@c @smallbook


@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2008 Cfengine AS

@end titlepage


@c *************************** File begins here ************************


@ifinfo
@dircategory Cfengine Training
@direntry
* cfengine Modularization:
                        Cfengine is a language based tool specifically
                        designed for configuring and maintaining
                        Unix-like operating systems attached
                        to a TCP/IP network.
@end direntry
@end ifinfo

@ifnottex
@node Top, Cfengine's package interface, (dir), (dir)
@top Cfengine-Packages
@end ifnottex


@ifhtml
@html
<a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>

<h2>Summary of contents</h2>

@end html
@end ifhtml

@c **********************************************************************
@c CHAPTER
@c **********************************************************************


@cartouche

In this module you will learn about

@itemize @bullet
@item 
How to verify packages are installed
@item 
How to check package versions
@item
How to install and remove new packages

@end itemize
@end cartouche


@menu
* Cfengine's package interface::  
@end menu




@c -----------------------------------------------------------------------


@node  Cfengine's package interface,  , Top, Top
@chapter Cfengine's package interface



In the last few versions, a new section packages has been added to the
input language, which lets us interface to native package
managers. The syntax is flexible enough that we can specify certain
criteria about the package, and as you'd expect, we can also define
some classes. Policies for these items are specified in the "package"
stanza.

@menu
* Syntax of packages::          
* Example of packages::         
* Package upgrade or install::  
@end menu

@node Syntax of packages, Example of packages, Cfengine's package interface, Cfengine's package interface
@section Syntax of packages

@smallexample
control:

   DefaultPkgMgr = ( @var{rpm|dpkg|sun|portage|freebsd} )

	@var{RPM|DPKG|Sun|Portage|FreeBSD}InstallCommand = ( "$(OS_SCRIPTS)/install_pkg %s" )
	@var{RPM|DPKG|Sun|Portage|FreeBSD}RemoveCommand = ( "$(OS_SCRIPTS)/remove_pkg %s" )


packages:
   
        package_name version=@var{number} cmp=@var{gt|ge|lt|le|eq|ne} action=@var{install|remove}

@end smallexample

The setting in the @code{control} section specifies the package
management software that is in use, as well as the preferred command
used to install a software package as this is not unique. These
directives illustrate the use of operating system-based classes within
policies for defining a different installation command for different
Linux distributions. Here are some examples:


@node Example of packages, Package upgrade or install, Syntax of packages, Cfengine's package interface
@section Example of packages

@smallexample

control:
	actionsequence = ( shellcommands packages )

	redhat::
		DefaultPkgMgr = ( rpm )
                RPMInstallCommand = ( "/usr/bin/yum -y install %s" )
                RPMRemoveCommand = ( "/bin/rpm -e %s" )

  #   DefaultPkgMgr = ( rpm )
  #   RPMInstallCommand = ( "/usr/bin/yum -d 0 -e 0 -y install %s" )
  #   RPMRemoveCommand = ( "/usr/bin/yum -d 0 -e 0 -y remove %s" )

	debian::
		DefaultPkgMgr = ( dpkg )
		DPKGInstallCommand = ( "/usr/bin/apt-get -y install %s" )
		DPKGRemoveCommand = ( "/usr/bin/dpkg -r %s" )

  # DPKGInstallCommand = ( "/usr/bin/aptitude -y -o quiet=1 -o APT::Get::AllowUnauthenticated=true -o aptitude::Cmdline::ignore-trust-violations=yes -o Dpkg::Options::=--force-confdef -o Dpkg::Options::=--force-confold install %s" ) 

	suse::
		DefaultPkgMgr = ( rpm )
                RPMInstallCommand = ( "/usr/bin/yast2 -i %s" )
                RPMRemoveCommand = ( "/bin/rpm -e --nodeps %s" )

	solaris::
		DefaultPkgMgr = ( sun )
	    SunInstallCommand = ( "/usr/sbin/pkgadd -n -d %s" )
	    SunRemoveCommand = ( "/usr/sbin/pkgrm -n %s" )

	gentoo::
		DefaultPkgMgr = ( portage )
	    PortageInstallCommand = ( "/usr/bin/emerge %s" )
	    PortageRemoveCommand = ( "/usr/bin/emerge -C --nodeps %s" )

	freebsd::
		DefaultPkgMgr = ( freebsd )
		FreeBSDInstallCommand = ( "/usr/sbin/pkg_add %s" )
		FreeBSDRemoveCommand = ( "/usr/sbin/pkg_delete %s" )

shellcommands:

	debian::
		"/usr/bin/apt-get update" ifelapsed=240

packages:

	redhat.centos.192_168_1_100::
		nagios2 version=2.4 cmp=ge
		sysklogd version=0:0.0 cmp=ge action=remove

	redhat.fedora.192_168_1_200::
		apache2 version=0.0 cmp=ge action=install

	debian.ubuntu::
		libdb-dev action=install
		libssl-dev action=install
		flex action=remove
		bison action=remove

@end smallexample		


	In the packages stanza from example 2, the first rule checks
whether Nagios is installed. A warning will be generated if the
package is not present or if the installed version is earlier than
version 2.4. The second rule checks for the sysklogd package. If the
package is installed, then removes it. The third, the forth and the
fifth rules check for the @code{apache2}, @file{libdb-dev} and
@file{libssl-dev} package and installs them if they are not present on
the system. Similarly, the sixth and the seventh rules check for the
flex and bison package and remove them if they are installed on the
system.

We should note that be aware and careful when using automated package
management tools such as @code{yum}, @code{apt-get}, @code{yast2}, etc
to remove package with non-interactive option which is necessary
within cfengine to avoid interactive prompts, will also remove
everything that depends on that package, which can come as quite a
tragedy.

Best practice is to alway test using non-interactive option before
using as your RemoveCommand to see what you are getting into or
another approach is to use another commands that let you explicit
about removing dependent packages, for instace: @samp{rpm -e} or
@samp{dpkg -r"}.

@c ************************************************
@node Package upgrade or install,  , Example of packages, Cfengine's package interface
@section Package upgrade or install?


Upgrade takes a match against what's @i{already} installed.
Basically, install will take any machine and `converge' it to having
the newer version of the package, even if the package was not
installed before.  Thus, think of install as `install or upgrade'.
(Very important: this is the way that @code{rpm}, @code{dpkg}, and
@code{portage} support work. Install for @code{freebsd}/@code{sun} doesn't do
upgrades too, just installs.)

Upgrade, on the other hand, means `upgrade only if the package has
been installed before'.  The version and comparison are used to
specify version numbers you want upgraded.

That leaves us with two options: e.g.

@smallexample
htop action=install version=0.7-1.el4.rf cmp=eq
@end smallexample

Any host that does not have htop 0.7 installed will install the  
most recent version of the repository.  This means if the version  
upstream is
.8, it's going to keep reinstalling .8 every time because its not .7!
Use @samp{cmp=ge} to prevent these re-installations.

@smallexample
htop action=install version=0.7-1.el4.rf cmp=lt
@end smallexample
Any host that is found with a version less-than 0.7 will have it
upgraded to whatever version is available in the repository

In summary: most of the time you want @code{install}.  Upgrading is
usually for security fixes to dependencies that are only installed on
some hosts.  For instance, if @code{libpng} has a security
vulnerability and you don't want to do make class based on ORing any
package that has @code{libpng} as a dependency, then just perform an
@samp{upgrade} to the @code{any} class and it will only be applied on hosts that
already have @code{libpng} installed due to the semantics.


@c =========================================================================
@c @node Index,  , Cfengine Methods, Top
@c @unnumbered Concept Index
@c @printindex cp
@c =========================================================================

@ifhtml
@html
<a name="Contents">
@end html
@end ifhtml

@contents

@ifhtml
@html
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
@end html
@end ifhtml

@bye
