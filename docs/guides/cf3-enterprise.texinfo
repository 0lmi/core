\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{CFEngineFrontPage} 

@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************
@c %** start of header
@setfilename cf3-enterprise.info
@settitle CFEngine and Enterprise Processes
@setchapternewpage odd
@c %** end of header

@titlepage
@title CFEngine and Enterprise Processes
@subtitle A CFEngine AS workbook
@author CFEngine AS

@c @smallbook
    

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2008- CFEngine AS

@end titlepage


@c *************************** File begins here ************************


@ifinfo
@dircategory CFEngine Training
@direntry
* CFEngine Modularization:
                        CFEngine is a language based tool specifically
                        designed for configuring and maintaining
                        Unix-like operating systems attached
                        to a TCP/IP network.
@end direntry
@end ifinfo

@ifnottex
@node Top, Enterprise integration, (dir), (dir)
@top CFEngine-Enterprise-Manual
@end ifnottex

@ifhtml
@html
<a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>
@end html
@end ifhtml
@iftex
@contents
@end iftex

@c **********************************************************************
@c CHAPTER
@c **********************************************************************


@menu
* Enterprise integration::      
* CFEngine past and present::   
* ITIL past and present::       
* A meeting of mind-sets::      
* Using CFEngine to implement ITIL objectives::  
* Summary::                     
* ITIL glossary::               
@end menu

@c **********************************************************************
@node Enterprise integration, CFEngine past and present, Top, Top
@chapter Enterprise Integration

@menu
* Business alignment::          
* ITIL introduced::             
* Business processes and goals::  
* About Promises::              
* Is automation worthwhile?::   
@end menu

@c **********************************************************************
@node Business alignment, ITIL introduced, Enterprise integration, Enterprise integration
@section Business alignment

The goal of most IT installations is to work as a support
infrastructure for some other primary activity, such as the running of
a business or other organization.  Even if the primary activity is the
design of computer systems, or the writing of software, the supporting
infrastructure is a tool whose management is in principle separate
from the main business goals. As organizations become larger, the
management of the IT system and other ancillary activities frequently
become isolated from ``front line'' activities.

IT infrastructure is an enabler, so it is important to ensure that it
succeeds in this task. How do we do this?  This document is about how
to make CFEngine-management best support primary business or organizational
processes.

We write this document in the light to two trends: the demotion of
system administration as a job description and the rise of service
oriented thinking to replace it, along with monolithic design
philosophy of systems.  Service orientation is not so much a
technological innovation as it is a different kind of social
structure. It is a move away from hierarchy as the main model of
organization, toward generalized network structure. In computer
parlance, service orientation is essentially a peer to peer
structure. There are no automatic kings or commanders in chief, only
peers who need help from other peers. If such key positions arise,
they emerge naturally by necessity, not by presumption.

For example, in the 1960s factory work in the United Kingdom was
organized hierarchically with powerful unions attending to a dutiful
``separation of concerns'', much like an idealized object oriented
system. To build a ship, one would have to ask the management to ask
panel producers for panels, then when they were finished they would
send the message back up the hierarchy so that management would
schedule the welders to arrive, then the painters and so on. Much
delay and inefficiency was caused by this organizational bureaucratic
structure.

Although this behaviour persists to a lesser extent, today we use more
direct communication between the parts that need to connect and so
save much time and overhead. This service oriented thinking can be
applied to computing services, their organization and even the support
of those computing services. The service model can be applied at all
levels.

In the late 1980s it was realized that a service oriented view of
management could profitably be formalized so as to be of benefit to
all organizations. This began the Information Technology
Infrastructure Library, building on the experience of leaders in
government and industry, including organizations such as the British
Broadcasting Corporation, the office of Government Commerce and others.

@c **********************************************************************
@node ITIL introduced, Business processes and goals, Business alignment, Enterprise integration
@section ITIL introduced

The IT Infrastructure Library (ITIL) has emerged as a de-facto set
of ideas about service delivery. It is not based on any theoretical
model or design criteria. It is rather a set of self-proclaimed @emph{best
practices} compiled by representatives from government and industry.
As such its claims can be discussed, but we shall not do so here.
We shall refer to ITIL because it has become a popular set of
guidelines for all manner of IT organizations, and because it promotes
the idea of IT-business @emph{alignment}.

ITIL was an important source of concepts and processes documented in
the following British and ISO standards:

@itemize
@item BS 15000
@item ISO/IEC 20000 (successor of BS 15000)
@end itemize

ITIL now encompasses various books and courses and has its own
qualification scheme allowing for a certification of Service Managers
 or IT staff.

The key concepts of ITIL include @emph{service and process orientation}, and
service orientation is an important model for system organization
because it can encompass everything from the monolithic hierarchical
systems of yesteryear to modern day peer to peer architectures which
better mirror a free-market economic business interaction. It can be
applied to computer-provided services (e.g. web services, or even
configuration operations like CFEngine) or it can be applied to human
services and operations such as help desks and support. This makes it
an important centre-piece in the discussion.

ITIL has its own particular terminology for discussing service related
matters.  To relate these to the use of a technology such as CFEngine
we need to understand the words and how they are used. ITIL uses many
terms and phrases in a different way to system
administrators.

The verb ``to manage'' originally meant ``to cope''. Only more recently
has strategic thinking changed it into a transitive verb: something that
we do to systems, like driving a car, or flying a plane. 

Today the term ``management'' signifies the introduction of a
bureaucratic level of governance, to control and verify the workings
of a system. The terminology this has come about mainly because
the people who wrote ITIL live in that kind of world and understand
things through these eyes. Ironically, computer engineers now speak
of ``self-management'' and ``autonomics'' to recover the original
idea of systems that can cope.

In this document we have two principal aims:
@itemize
@item To explain a number of
patterns for using CFEngine to allow systems to cope with business
needs.

@item To demystify ITIL for technicians and
engineers who do not naturally respond to business-speak, 
relating CFEngine's capabilities (both the technical aspects that are
well known and the non-technical aspects of instrumentation and
reporting that are less well known) to the goals of ITIL.
@end itemize


@c **********************************************************************
@node Business processes and goals, About Promises, ITIL introduced, Enterprise integration
@section Business processes and goals

What do we need to make a business? Do we need a demand for a
``product'', a workflow to implement it, a supply (chain)
mechanism for selling it to a market? It turns out that the service
abstraction is a paradigm that fits all enterprises without too much
shoe-horning.

Businesses have probably many goals in their grand designs: they have
high level visions, notions of secure and best practices, sometimes
even ethical policies. All of these can be couched in the language of
promises to behave in some way.

Now, we can ask: what does it mean to align an IT infrastructure to
this business goal to provide @i{S}?  First, for IT systems to have any
impact on the business goal at all, the business must rely on the IT
system in some way. This could either be directly, in the manner of an
e-commerce web-site, or it might be indirectly, for instance by
providing drawing and modelling software in an architect's office. In
either case there is a workflow in which an IT system plays an
intermediary role in the workflow process.

In fact, it does not matter whether this is an IT system, a human being
or a steam-powered engine. What is key is that there is a technology
playing an intermediate role in the performance of a service.
We can display this as the workflow diagram shown by
the dotted lines in the figure.
The business @i{B} would like to provide service @i{S} to its customer @i{C};
in actuality this requires the help of intermediary @i{I}.

@image{intermediate,10cm,,Intermediate agent,png}

Inserting an intermediate agent into a business process. The dotted
lines show a work flow path. The arc shows a promise the business
would like to make to the end customer -- but promise theory says that
it cannot if it does not have direct contact.

Promise theory has several implications, and one of them is that an
agent cannot promise something @emph{with confidence} to an agent it is
not directly in contact with. This is because agents can only vouch
for their own behaviour. They cannot promise what an intermediate
agent would do.  This has implications for the business.

Suppose a business want to make a promise to its customer, but knows
that it must rely on intermediaries (the IT department for example) to
do so. Promise theory tells us that the business representative making
the promise requires promises from every intermediate agent in the
chain, and each of the agents in that chain require promises from down
the chain too.

It is beyond the scope of this document to explain all of those
promises.  What CFEngine allows a business to do is to automate many
of those promises -- or make them @emph{autonomic} (self-managing).

@menu
* Teams control structures and collaboration::  
@end menu

@c **********************************************************************
@node Teams control structures and collaboration,  , Business processes and goals, Business processes and goals
@subsection Teams and collaboration

Humans are poor at reliable, repetitive work but they are infinitely
superior at creative work and decision-making. Modern theory on
success in business rejects the classic views of management with
militarized or bureaucratized chains of command and
control in favour of more human-creative
structures. Creative and adaptive workflow requires high level of
decentralization and autonomy, while at the same time protecting the
core values of the organization.

Team work is a key element in decentralized organization -- both for
humans and computers. IT departments are often organized in this way,
for instance. Teams do not exist because they maximize production of
every individual, nor do they make an organization more predictable or
controllable. They exist because humans need continual motivation and
emotional support -- and indirectly this sustains workflow and adds
creativity to a business. One often overlooks the team-aspect of
coping when considering computer management, in favour of hierarchical
design. CFEngine does not force us into hierarchical systems however,
so we should not discard the smaller team idea too soon.

@image{hierarchy,10cm,,Hierarchy has long traditions but modern thinking favours teams.,png}

CFEngine is complex enough for it to make sense to delegate
responsibility for different issues.  An organization will generally
consist of many groups and teams already, each with their own special
needs and each craving its own autonomy. CFEngine and promise theory
were designed for precisely this kind of environment. CFEngine allows
cooperation and sharing without allowing central managers to ride
roughshod over local needs.

Teams thrive by discussion and interaction within the framework of a
policy or vision, allowing variation and arriving at a consensus when
necessary. Success in a team depends on a combination of abilities
working together not undermining one another. Conflicts in the
promises made by team members reveal design problems in the group. An
analysis of promises (CFEngine's model of collaboration) is a
significant tool for understanding and enabling businesses.

M. Belbin a researcher in teamwork has identified nine abilities or
roles (kinds of promise) to be played in a team collaboration:

@enumerate
@item Plant -- a creative ``ideas'' person who solves problems.

@item Shaper -- this is a dynamic member of the team who thrives on
pressure and has the drive and courage to overcome obstacles.

@item Specialist -- someone who brings specialist knowledge to the group.

@item Implementer -- a practical thinker who is rooted in reality and can turn ideas into
practice (who sometimes frustrates more imaginative high flying
visionaries).


@item Resource Investigator -- an enabler, or someone who knows where to
find the help the team needs regardless of whether the help is
physical, financial or human. This person is good at networking.


@item Chairman/Co-ordinator -- an arbitrator who makes sure that
everyone gets their say and can contribute.

@item Monitor-Evaluator -- is a dispassionate, discerning member who can
judge progress and achievement accurately during the process.


@item Team Worker -- someone concerned with the team's inter-personal
relationships and who is sensitive to the atmosphere of the group.



@item Completer/Finisher -- someone critical and analytical who looks after the details of
presentation and spots potential flaws and gaps. The completer is
a quality control person.
@end enumerate

His model has little room for technical workflow arguments. It is
entirely concerned with the creative process. This is probably
significant.  We should ask ourselves: how can we use the freedom to
organize into specialized teams to maximize human creativity, while
passing hard work over to machines. Solving this problem is what
CFEngine is about.


@node About Promises, Is automation worthwhile?, Business processes and goals, Enterprise integration
@section About Promises

@menu
* A theory::                    
* Basic definitions::           
@end menu

@c **********************************************************************
@node A theory, Basic definitions, About Promises, About Promises
@subsection A theory for ITIL

ITIL has no theory to back it up, so we have to look elsewhere for a
motivation of its practices. Promise theory is an attempt to do just
this for a service oriented model in which peers make promises to one
another. So it ought to work for ITIL also.
The advantage of promise theory is that it helps us to see how
CFEngine can be used, because promises provide a simple
picture of how CFEngine works.

@cartouche
Think of CFEngine as a general tool for automatically making sure that promises are kept.
@end cartouche

The popular service concept fails to capture one thing very clearly, namely the
distinction between making a promise and keeping a promise. A
service implies that something will be provided but it does not
specify when. 

Suppose we ask a security company to protect our assets. The company
might promise to deploy guards, or alarm technology, or it could
simply promise that you will be safe without explaining how the
promise will be kept. The promise does not necessarily imply any
action required to maintain this state of safety, but we still pay the
company for the service to keep this promise anyway. Trust plays an
important role, of course. 

Promise theory helps us to understand services in all forms by forcing
us to think carefully about the concept of @emph{autonomy}. Autonomy
implies several things: for instance, privacy of information,
independence of decision and responsibility for one's own
behaviour. The concept of autonomy is like a filter that makes us
think carefully about things that we often take for granted. It
is a good discipline, forcing us to confront what we think we know
about systems.

The agents of promises are humans, computers or any entity that can be
associated with a promise even if by association with its owner or
designer. They are said to be autonomous if they cannot be forced to
make any promises about their behaviour by an outside agent.  A useful
principle for understanding systems is the maximal @emph{separation of
concerns} and promises help us to separate independent issues.

Separation of concerns is only half the story however.  Promises are
also about describing how the parts of a system work together, just as
in team-work. Promises provide the glue that allows completely
autonomous parts to form an organization.  We are not allowed to think
about ``control'' or ``command'', only about voluntary cooperation.
Keep these ideas in mind when reading this document.

@c **********************************************************************
@node Basic definitions,  , A theory, About Promises
@subsection Basic promise definitions

We can use the language of promises to make clearer definitions.
@itemize
@item @emph{Service}: a promise to act or provide a resource.
The promise is made from a `server' agent @i{S} to one or more external agents
which we call the clients.

@item @emph{Agreement}: a mutual acceptance of knowledge by two agents (``the agents agree''). 
The knowledge that is agreed to is called the body of the
agreement. Note that the term ``agreement'' is sometimes used
incorrectly to mean ``contract''.  Agreement is often
signified by signing the body, or some equivalent declaration.  In
promise theory an agreement is a pair of @emph{use-promises} between two
parties to acknowledge acceptance of the agreement body.

@item @emph{Contract}: a bilateral bundle of proposed promises between two agents, 
intended to serve as the body of an agreement.

@item @emph{Service Level Agreement} An agreement between two parties whose body
describes a contract for service delivery and consumption.
@end itemize


Service Level Agreements (SLA) are now a well-known part of the 
customer-business scenario.
How are promises different from Service Level Agreements (SLA)?
Promises are more primitive than agreements. Agreements bind two
parties to a collection of bilateral decisions that have been made in
advance.  An agreement implies an existing infrastructure on which to
agree.  A promise on the other hand is an entirely autonomous
statement about agents' behaviour (ad hoc). Showing only the promises in a
system does not imply any agreement between the parties, only
indications about their likely behaviours.

In other words, seeing the promises that have been made, an external
observer could calculate effective service levels that have been
promised without any agreement taking place. Promises are therefore
more fundamental than agreements to the predictability of the system.


@c **********************************************************************
@node Is automation worthwhile?,  , About Promises, Enterprise integration
@section Is automation worthwhile?

Process automation is an investment which has its own cost.  The
benefits are not merely saved manpower but improved consistency or
certainty of process. Automation provides an automatic quality assurance.

A simple argument against automation goes like this: if I can fix it
in five minutes then it is not worth automating, unless the automation
takes less time than that.

The argument is simplistic. Before dismissing automation, one should
ask questions like this:
@itemize
@item How many of these five minute periods occur in the long run?
@item How much time was needed to diagnose each of them? 
@item Could the problems have been avoided altogether by proactive maintenance? 
@end itemize
One of the benefits of automation is in prevention, another is in
documenting institutional learning by codifying the processes
required for the avoidance of incidents. A tool like CFEngine which
separates intention (promises) from action makes this kind of
documentation highly readable and allows the learning to penetrate the
workflow processes directly.

@c **********************************************************************
@node CFEngine past and present, ITIL past and present, Enterprise integration, Top
@chapter CFEngine past and present


CFEngine is a free software package for automating the installation
and maintenance of networked computers. The project began in 1993 and
it has been in widespread use since 1995. CFEngine is available for all major
Unix and Unix-like operating systems, and it will also run under
NT-derived Windows operating systems via the Cygwin Unix-compatibility
environment/libraries.

CFEngine scales easily from a single host to tens of thousands of
hosts. As of this writing, the largest installations we know of
regulate around 50,000 machines under a common administration.
CFEngine can manage many aspects of system configuration and
maintenance, including the following:

@itemize
@item Performing post-installation tasks such as configuring the network interface. 
@item Editing system configuration files and other files. 
@item Creating symbolic links. 
@item Checking and correcting file permissions and ownership.
@item Deleting unwanted files. 
@item Compressing selected files. 
@item Distributing files within a network.
@item Automatically mount NFS file systems. 
@item Verifying the presence and integrity of important files and file systems.
@item Executing commands and scripts. 
@item Applying security-related patches and similar system corrections. 
@item Managing system server processes. 
@end itemize

CFEngine's purpose is to implement policy-based configuration
management. In practical terms, this means that CFEngine greatly
simplifies the tasks of system configuration and maintenance. For
example, to customize a particular system, it is no longer necessary
to write a program which performs each required action in a procedural
language like Perl or your favorite shell. Instead, you write a much
simpler policy description that documents @emph{how} you want your
hosts to be configured. The CFEngine software determines what needs to
be done in terms of implementation and/or remediation from this
specification. Such policy descriptions are also used to ensure that
the system remains configured as the system administrator wishes over
time.

Here is a brief example of such a policy description which verifies and
installs a number of packages in a convergent way:

@smallexample

body common control
{
bundlesequence => { "packages" };
}

#############################################

bundle agent packages
{
vars:

 "match_package" slist => { 
                          "apache2", 
                          "apache2-mod_php5",
                          "apache2-prefork",
                          "php5" 
                          };
packages:

  "$(match_package)"

     package_policy => "add",
     package_method => yum;

}

@end smallexample

This simple configuration is divided into four stanzas, each
introduced by a colon-terminated keyword, specifically
@code{control:}, @code{files:}, @code{copy:} and @code{tidy:}. The
@code{control} stanza defines a list of directories which we've named
@var{tmpdirs} which we'll use later (in the @code{tidy} stanza).

The @code{files} stanza specifies that all of the files in the
directory @file{/usr/local/bin} should be owned by user root and
group bin and have the file mode 755. When CFEngine runs with this
configuration description it will correct any ownership and/or
permissions which deviate from these specifications.  Thus, this
stanza serves to implement a policy about the proper ownerships and
permissions for the executables in the local binaries directory.

The @code{copy} stanza prescribes different configurations for Linux
and Solaris systems. On Solaris systems, files in @file{/etc/pam.d}
will be updated with those in the directory @file{/config/pam/solaris} on a master server when the latter are newer. On
Linux systems, only the file @file{/etc/pam.d/common-auth} is updated
from the PAM master configuration because the Linux systems in
question use the PAM include file mechanism to propagate this file's
stacks to all of the PAM-enabled services. Note, however, that both of
these specifications implement the same underlying system
configuration maintenance policy: update the relevant PAM
configuration files from the master server if necessary.

The final, @code{tidy} stanza illustrates the use of implicit
looping. The single directive in the example applies to each of the
directories in the @var{tmpdirs} list. For each directory, CFEngine
will delete all items in the directory or any of its subdirectories
which have not been accessed in seven days (including ones where the
filename begins with a period). Like the other directives in this
sample configuration file, this stanza implements a policy: items in
temporary directories which have not been used within a week will be
deleted.

All CFEngine configuration descriptions are variations on these an
similar themes, albeit more elaborate ones.  Before turning to more
details about the technical aspects of using CFEngine, a brief
consideration of the most important underlying and guiding theoretical
concepts is in order.

@menu
* Fundamental Concepts::        
* CFEngine Components::         
@end menu

@c **********************************************************************
@node Fundamental Concepts, CFEngine Components, CFEngine past and present, CFEngine past and present
@section Fundamental CFEngine Concepts

As we've stated, CFEngine operates on hosts in order to bring their
configurations in line with the specified policies. 
We need to define some terms.

@table @i
@item Host
A host is a single computer that runs an operating system like Unix,
Linux or Windows. We will sometimes talk about machines too, and
a host can also be a virtual machine supported by an environment VMWare or Xen/Linux.

@item Policy
This is a specification of what we want a host to be like, or how
we want it to behave. A policy is essentially a piece of
documentation that describes technical details and
characteristics. CFEngine implements policies that are specified via
directives of the sort we just considered.

@item Configuration
The configuration of a host is the actual state of its resources, e.g.
the permissions and contents of files, the inventory of software installed, etc. It
is the `state of affairs' on a particular host at a given time.
@end table

What are we aiming for with CFEngine? The answer is: @emph{policy
conformant configuration}. We want to formulate a specification of not
just one host, but usually many, including how they all interact,
perhaps to solve a business problem; then we want to leave the
details, implementation and maintenance to a robot agent:
@code{cfagent}.

Humans are good at understanding input and thinking up solutions but they
not very reliable at implementation: @emph{doing} things reliably. Machines and
software agents are good at carrying out tasks reliably, but are not
good at understanding or finding actual solutions. With CFEngine, you
let the distinct parts of your human-computer organization concentrate
on what they are each good at.

CFEngine can also produce reports about systems for monitoring the
performance and compliance with policies. This is an important aspect
of business integration as service providers want to know whether they
are delivering what they have promised, and whether their money has been
spent wisely.

@node CFEngine seen from an ITIL perspective
@section CFEngine seen from an ITIL perspective

The figure below shows the three cornerstones of CFEngine and how they relate to one another.

@image{CFEngine-schematic,10cm,,The key aspects of CFEngine from an ITIL perspective,png}

@itemize
@item @code{cf-agent} is the engine for configuration management. It takes
a policy (expressed in promises) and ensures continuously that promises are kept.

@item @code{cf-monitord} is the lightweight monitoring agent, that observes the states
of the system that can not be specified by policy, i.e. performance aspects that are determined
by the environment in which a system is placed.

@item @code{cf-know} is the knowledge agent which builds a semantic web-overview of
the policy and state of the system, using topic maps.
@end itemize

This triumvirate of components exchanges information in all directions to build
a complete, reflective, policy-based management framework.

The @i{convergent automation} that CFEngine provides, along with its model of
promises, provides an immediate ITIL process loop for @i{incident management},
repairing deviations from a given release of policy.

What CFEngine tries to achieve is the separation of design from implementation,
in much the way that style-sheets do this for web browsers. The CFEngine policy
is a (probably incomplete) specification of all machines' configurations,
and the @code{cf-agent} is an implementation engine. When intention and action
have been separated, all that is really left for humans to govern is @i{knowledge}.

Policy is, of course, knowledge about our @i{intentions} for the
system. Monitoring data are knowledge about the state of the system
that we have not directly planned for.  Knowledge about unforeseen
events helps us to inform the next revision of policy, and builds up
historical records about system behaviour.  Thus, the information
about actual happenings feeding back into new @i{releases} of policy is
what ÃTIL refers to as @i{problem management}.

In this way, CFEngine supports the process of knowledge management `DIKW',
from Data to Information to Knowledge to Wisdom.



@node How is CFEngine different from a classical CMDB?
@section How is CFEngine different from a classical CMDB?

One of ITIL's central requirements is the Configuration Managment
Database or CMDB.  According to ITIL this database is built up of
inventory information and relationships.  The database starts out as
an archive of collected information but at some point it stops being a
record of obvservation and starts becoming an authoratative template
for defining and `imaging' systems.

The CFEngine view is that a database is only ever a report cache.  It
is never the authoratative source of a configuration, because a ER
data model does not provide an expressive enough language for
describing a system. CFEngine has its own policy language, with
special properties and optimizations for the authoratative intentions
of the system. Thus @code{cf-agent} reads policy, written in the
CFEngine language, and implements it. Then the agent itself, in
concert with other components like @code{cf-monitord} reports back on
what really happened, and this is cached in a database (which might be
called a CMDB). This is the separation of duties that CFEngine holds
to.

One important difference is that relationships do not have to be
data-mined from the database. They can be coded directly in policy,
and thus they too can be authoratative, not merely guessed.


@menu
* Promises actions operations::  
* Convergence::                 
* Classes and Declarations From One to Many Hosts::  
* Voluntary Cooperation::       
* Scalability::                 
@end menu

@node Promises actions operations, Convergence, Fundamental Concepts, Fundamental Concepts
@section Promises, Actions and Operations

CFEngine's philosophy fits quite well with the service oriented
approach to computing.

A CFEngine policy can be thought of as a list of promises which the
system makes to some auditor about its configuration. Most of the
these promises involve the possibility of @emph{change} to make a host
fulfills its policy promises. We call such changes @emph{actions} or
@emph{operations}. As you probably already guessed, the auditor in this
scenario is part of CFEngine itself. Cfagent is also the mechanic
or surgeon that performs the operations on the system, if it does not
meet its promises.

By describing its operation in this manner, we can think of configuration
management as a service that is provided, a service that is intimately
connected with monitoring and maintenance, and which can be ``bought''
on demand without necessarily subordinating a system to a central authority.

@table @i
@item Operation
A unit of change is called an operation. CFEngine deals with changes to
a system, and operations are embedded into the basic sentences of a
CFEngine policy. They tell us @emph{how} policy constrains a host, 
in other words, how we will prevent a host from running away.
@end table

For example, in the software package promise above,

@smallexample

packages:

  "$(match_package)"

     package_policy => "add",
     package_method => yum;

@end smallexample

There are implicit operations (actions) in this declaration: specifically, the
operations that will change the packages if/when they do not conform to this
simple specification.

@node Convergence, Classes and Declarations From One to Many Hosts, Promises actions operations, Fundamental Concepts
@subsection Convergence

A key property of CFEngine is convergence. This is an important characteristic
that distinguishes it from general computer languages. It is a property that
helps to prevent systems from diverging: running away in an uncontrollable
fashion.

@table @i
@item Convergence
An operation is convergent if it always brings the configuration of a
host closer to its ideal, policy-conformant state and has no effect if
the host is already in that state.  We shall sometimes call it a
``correct state'' or a ``healthy state,'' using the metaphor that a
badly configured host is suffering from a kind of sickness.
@end table

Here is an example used during the editing of an ASCII file:

@smallexample

insert:

   "@var{Important configuration line}";

@end smallexample
This operation tells CFEngine to insert the given text (by default at the end of a
file), only if it is not already there. The policy-conformant configuration is
therefore that the line is present, and once that is achieved nothing
more will be done. We say that the operation @code{insert}
is @i{convergent}.

Don't underestimate the value of convergence. It provides you with
stability. Because CFEngine's language interface strongly discourages
you from doing anything non-convergent, it also help to prevent
mistakes. The price is that you will have to learn to think in a
convergent way---and that is new for most people who come to CFEngine for
the first time.

@c **********************************************************************
@node Classes and Declarations From One to Many Hosts, Voluntary Cooperation, Convergence, Fundamental Concepts
@subsection One or Many Hosts

One of the features that makes CFEngine policies readable is the
ability to hide away all of the complex decision-making that
needs to be performed by the agent. To realize this ambition, CFEngine
uses a @emph{declarative} language to express policy.


A declarative language is simply a structured list of sentences (in
the case of CFEngine, it is a list of policy promises). It is stated
in no particular order; it describes a final goal that is to be
achieved. The details of how one gets there are left implicit: to be
evaluated and implemented by the engine that interprets the
specification. This is in contrast to @emph{procedural} or
@emph{imperative} languages, such as shell or Perl which micro-manage
every step along the way.

In an imperative language, one focuses on the procedure. In a declarative 
language, one focuses on the intention, or the presumed result.

One example of this is the use of classes in CFEngine. Classes are a
way of making decisions, without writing many ``if-then-else''
clauses. A class is an identified which has the value ``true'' when a
particular test is true. It is a Boolean variable; if you like it
caches the result of an ``if'' test. The benefit of classes is that
all of the testing can be hidden away in the bowels of CFEngine, and
only the results need be visible if or when they are needed.

@table @i
@item Classes
A class is a way of slicing up and mapping out the complex environment
of one or more hosts into regions that can then be referred to by a
symbol or name. They describe scope: @emph{where} something is to
be constrained.
@end table

For example, the class @code{debian} is true if and only if cfagent is
running on a host that has Debian Linux as its operating system.

@node Voluntary Cooperation, Scalability, Classes and Declarations From One to Many Hosts, Fundamental Concepts
@subsection Voluntary Cooperation

It is a fundamental property of CFEngine components that every host
retains its individual autonomy. A host can always opt out of CFEngine-based governance if its administrator wants to.
This principle leads to a fundamental design and implementation decision:


@table @i
@item Autonomy
No CFEngine component is capable of receiving information that it
has not explicitly asked for itself, nor can it be advised or commanded
by an outside agent without requesting such advice.
@end table

It is important to understand what this means. It does not mean that
centralized control of hosts cannot be achieved. Centralized control
is the way that most users choose to use CFEngine. Indeed, all you have
to do to achieve centralized control is to make a policy decision for
all your hosts to fetch policy specifications from a central authority.

Autonomy does mean that if your environment has some small groups or
sub-cultures with special needs, it is possible for them to retain
their special identity. No one claiming to be their self-appointed
authority can ride rough shod over their local decisions.

@emph{Where does policy come from then?}
Each host works from a policy specification that CFEngine expects to
find in a local directory (usually @file{/var/cfengine/inputs} on a
Unix-like host). If you want your host to be controlled from some
central manager or authority, then your policy must contain
bootstrapping specifications that say: ``@emph{it is my decision that
I should download and follow the policy specification located
at the central manager}.''

Each host can turn this policy decision off at any time.
This is a key part of the CFEngine security model.


@c **********************************************************************
@node Scalability,  , Voluntary Cooperation, Fundamental Concepts
@subsection Scalability

CFEngine's scalability is at least as good as any other system,
because it allows for maximal distribution of
workload.

@table @i
@item Scalable distributed action
Each host is responsible for carrying out checks and maintenance
on/for itself, based on its local copy of policy.
@end table

This does not mean that you are immune from making bad decisions.
For example, network services can always be a bottleneck if you ask 10,000 hosts
to fetch something from one place at the same time.

The fact that each CFEngine agent keeps a local copy of policy (regardless 
of whether it was written locally or inherited from a central
authority) means that CFEngine will continue to function even if
network communications are down.

@node CFEngine Components,  , Fundamental Concepts, CFEngine past and present
@section CFEngine Components

The CFEngine software consists of a number of components: separate
programs that work together (see figure). The components differ
between version 1 and version 2. We shall only discuss CFEngine 2
here, as CFEngine version 1 is no longer supported, and you are strongly
advised to use version 2. In addition, CFEngine version 3 is being
developed at the time of writing, but this will take a number of years
before it can fully replace version 2. It will incorporate the state
of the art in Network and System Administration research, building on all
the lessons learned from versions 1 and 2.

The components of CFEngine are:


@itemize
@item @code{cfagent}: Interprets policy promises and implements them in a convergent manner.
The agent can use data generated by the statistical monitoring engine @code{cfenvd} and
it can fetch data from @code{cfservd} running on local or remote hosts.

@item @code{cfexecd}: Is a scheduler and wrapper which executes @code{cfagent} and logs
its output (optionally sending a summary via email). It can be run in
daemon (standalone) mode, or it can be run from @code{cron}
on a Unix-like system.

@item @code{cfservd}: A server daemon that serves file data. It can also be configured
to start @code{cfagent} immediately on receipt of a connection from @code{cfrun}. No
actual data can be passed to this daemon.

@item @code{cfrun}: A helper application that polls hosts and asks them to run @code{cfagent}
if they agree.

@item @code{cfenvd}: A statistical state monitor that collects statistics 
about resource usage on each host for anomaly detection purposes. The information is
made available to the agent in the form of CFEngine classes so that the agent can check for and respond
to anomalies dynamically.

@item @code{cfkey}: Generates public-private key pairs on a host. You normally run this
program only once, as part of the CFEngine software installation process.

@item @code{cfshow}: Displays the @code{cfagent} database contents in ASCII format, should you ever
become interested in its internal memory.

@item @code{cfenvgraph}: Dumps @code{cfenvd}'s statistical database contents in a form
that can be used to plot graphs showing the normal behavior of a host in its
environment.
@end itemize

@image{cfdiag,10cm,,CFEngine Components and the Connections Between Them,png}

This figure illustrates the relationships among CFEngine
components on different hosts. On a given system, @code{cfagent} may
be started by the @code{cfexecd} daemon; the latter also handles
logging during @code{cfagent} runs.  In addition, operations such as
file copying between hosts are initiated by @code{cfagent} on the
local system, and they rely on the @code{cfservd} daemon on the remote
system to obtain remote data.


@c **********************************************************************
@node ITIL past and present, A meeting of mind-sets, CFEngine past and present, Top
@chapter ITIL past and present


The IT Infrastructure Library (ITIL) is a collection of books, in which
``best practices'' for IT Service Management (ITSM) are described. Today,
ITIL can be seen as a de-facto standard in the discipline of ITSM, for
which it provides guidelines by its current core titles Service
Strategy, Service Design, Service Transition, Service Operation and
Continual Service Improvement. ITIL follows the principle of
process-oriented management of IT services.

In effect, the responsibilities for specific IT management decisions
can be shared between different organizational units as the management
processes span the entire IT organization independent from its
organizational partition. Whether this means a centralization or
decentralization of IT management in the end, depends on the concrete
instances of ITIL processes in the respective scenario.


@menu
* ITIL and its versions::       
* Foundations::                 
* Tool Support::                
@end menu

@c **********************************************************************
@node ITIL and its versions, Foundations, ITIL past and present, ITIL past and present
@section ITIL and its versions

ITIL has its roots in the early 1990s, and
since then was subject to numerous improvements and enhancements.
Today, the most popular release of ITIL is given by the books of ITIL version 2 (often referred to as ITILv2),
while the British OGC (Office of Government Commerce), owner and publisher
of ITIL, is currently promoting ITIL version 3 (ITILv3) under the device "`ITIL Reloaded"'.

It is important to understand that ITILv3 is not just an improved version of
the ITILv2 books, but rather comes with a completely renewed structure,
new sets of processes and a different scope with respect to the issue of
IT strategies, IT-business-alignment and continual improvement. That is why, in the following,
we run through the basics of both versions, highlighting commonalities
and differences.


@menu
* ITIL Important Foundations::  
* ITILv2 Service Support and Service Delivery::  
* ITILv3 Management from the Service Life Cycle Perspective::  
@end menu

@node ITIL Important Foundations, ITILv2 Service Support and Service Delivery, ITIL and its versions, ITIL and its versions
@subsection ITIL: Important Foundations

It is the paradigm of process-oriented IT Service Management
that ITIL is based on. In addition, ITIL uses the Deming quality
circle as a model for continual quality improvement, where quality both
relates to the provided IT services as well as the management processes
deployed to manage these services. Continual improvement as to ITIL means
to follow the method of Plan-Do-Check-Act:

@itemize
@item Plan: Plan the provision of high-quality IT services, set up the required management processes for the delivery and support of these services, define measurable goals and the course of action in order to fulfill them.
@item Do: Put the plans into action.
@item Check: Measure all relevant performance indicators, and quantify the achieved quality compared to the quality objectives. Check for potentials of improvement.
@item Act: In response to the measured quality, start activities for future improvements. This step leads into the Plan phase again.
@end itemize

@c **********************************************************************
@node ITILv2 Service Support and Service Delivery, ITILv3 Management from the Service Life Cycle Perspective, ITIL Important Foundations, ITIL and its versions
@subsection ITILv2 Service Support and Service Delivery


Although ITILv3 has been released during the summer of the year 2007,
it is its predecessor that has achieved great acceptance amongst
IT service providers all over the world. And due to the fact that the
International ISO/IEC 20000 standard has emerged from the
basic principles and processes coming from ITILv2, it is this version
experiencing the biggest distribution and popularity.

The core modules of ITILv2 are the books entitled Service Support
and Service Delivery. While the Service Support
processes (e.g. Incident Management, Change Management) aim at
supporting day-to-day IT service operation, the Service Delivery
processes (e.g. Service Level Management, Capacity Management,
Financial Management) are supposed to cover IT service planning like
resource and quality planning, as well as strategies for customer
relationships or dealing with unpredictable situations.

@c **********************************************************************
@node ITILv3 Management from the Service Life Cycle Perspective,  , ITILv2 Service Support and Service Delivery, ITIL and its versions
@subsection ITILv3 Management from the Service Life Cycle Perspective

In 2007, ITILv2 has been replaced by its successor ITILv3, aimed at
covering the entire service life cycle from a management
perspective and striving for a more substantiated idea of IT business alignment.
Many of the ITILv2 processes and ideas have been recycled
and extended by various additional processes and principles. The five
service life cycle stages accordant to ITILv3 are:

@enumerate
@item Service Strategy: Common strategies and principles for customer-oriented, business-driven service delivery and management
@item Service Design: Principles and processes for the stage of designing new or changed IT services
@item Service Transition: Principles and processes to ensure quality-oriented implementation of new or changed services into the operational environment
@item Service Operation: Principles and processes for supporting service operation
@item Continual Service Improvement: Methods for planning and achieving service improvements at regular intervals
@end enumerate

The ITILv3 framework is sometimes reduced to the four Ps.

@itemize
@item Products (tools)
@item People (humans)
@item Partners (cooperation between parts of the organization)
@item Processes (execution and verification)
@end itemize


@c **********************************************************************
@node Foundations, Tool Support, ITIL and its versions, ITIL past and present
@section Service orientation and ITIL

Why service and process orientation? What is ITIL trying to do? As we mentioned
in the introduction, the `military' control view of human organization fell from
favour in business research in the 1980s and service oriented autonomy
was identified as a new paradigm for levelling organizations --
getting rid of deep hierarchies that hinder communication and open up
communication directly.


If one is cynical, one can interpret the signs of CEOs nervously
trying to put back some of the military thinking into process
management -- with definitions of authority and chains of
responsibility, but these chains are short and whenever ITIL says
``committee'', promise theory would say that all we need is a single
agent (a human or computer) and the internal details of it don't
matter. We should probably not think too literally about ITIL's choice
of words, which after all were born from a particular kind of
corporate culture and will not appeal to everyone.

If we look at ITIL through the eyeglass of a hierarchical organization,
some of its procedures could be seen as restrictive, throttling
scalable freedoms. We do not believe
that this is their intention. Rather ITIL's guidelines try to make a
predictable and reliable face for business and IT operations so that
customers feel confidence, without choking the creative process that
lies behind the design of new services.

@menu
* CFEngine in ITIL clothes?::   
* ITIL processes::              
* Service Strategy::            
* Service Design::              
* Service Operation::           
* Continual Service Improvement::  
@end menu

@c **********************************************************************
@node CFEngine in ITIL clothes?, ITIL processes, Foundations, Foundations
@subsection CFEngine in ITIL clothes?

CFEngine users are interested in the ability to manage, i.e. cope with
system configuration in a way that enables a business or other
organization to do its work effectively. They don't want reams of
human management because this is what CFEngine is supposed to
remove. To be able to use ITIL to help in this task, we have to first
think of the process of setting up as a number of services.  What
services are these? We have to think a little sideways to see the
relationship.

@itemize
@item Service - providing a sensible configuration policy, responding to discovered problems or the needs of end-users.
@item Change - an edit of the configuration policy, with appropriate quality controls.
@item Release - a new configuration policy, consisting of many changes. A new version of CFEngine? This could be a major and disruptive change so it should be planned carefully.
@item Capacity - having enough resources for cfservd to answer all queries in a network. Having enough people to support the processes of deploying and following CFEngine's progress.
@end itemize

You should keep this kind of thinking in mind, and train yourself to see every part
of a task in ``ITIL clothes''.

@c **********************************************************************
@node ITIL processes, Service Strategy, CFEngine in ITIL clothes?, Foundations
@subsection ITIL processes

The following management processes are in scope of ITILv3:

@itemize
@item Service Level Management: Management of Service Level Agreements (Alas), i.e. service level and quality promises.
@item Service Catalogue Management: deciding on the services that will be provided and how they
are advertised to users.
@item Capacity Management: Planning and provision of adequate business, service and resource capacities.
@item Availability Management: Resource provision and monitoring of service, from a customer viewpoint.
@item Continuity Management: Development of strategies for dealing with potential disasters.
@item Information Security Management: Ensuring a minimum level of information security throughout the IT organization.
@item Supplier Management: Maintaining supplier relationships.
@item Transition Planning and Support: Ensuring that new or changed services are deployed into the operational environment with the minimal impact on existing services
@item Asset and Configuration Management: Management of IT assets and Configuration Items.
@item Release Management: Planning, building, testing and rolling out hardware and software configurations.
@item Change Management: Assessment of current state, authorization and scheduling of improvements.
@item Service Validation and Testing: ensuring that services meet their specifications.
@item Knowledge Management: organizing and integrating experience and methodology for future reference.
@item Incident Management: responding to deviations from acceptable service.
@item Event Management: Efficient handling of service requests and complaints.
@item Problem Management: Problem identification by trend analysis of incidents.
@item Request Fulfillment: Fulfilling customer service requests.
@item Access Management: Management of access rights to information, services and resources.
@end itemize

@c **********************************************************************
@node Service Strategy, Service Design, ITIL processes, Foundations
@subsection Service Strategy

Service strategy is about deciding what services you want to
formalize. In other words, what parts of your system administration tasks can you
wrap in procedural formalities to ensure that they are carried out most excellently?

@c **********************************************************************
@node Service Design, Service Operation, Service Strategy, Foundations
@subsection Service Design

Service design is about deciding what will be delivered, when it will be delivered,
how quickly the service will respond to the needs of its clients etc. This stage is probably
something of a mental barrier to those who are not used to service-oriented thinking.

@c **********************************************************************
@node Service Operation, Continual Service Improvement, Service Design, Foundations
@subsection Service Operation

How shall we support service operation? What resources do we need to provide, both human
and computer? Can we be certain of having these resources at all times, or is there
resource sharing taking place? If services are chained into ``supply chains'', remember that
each link of the chain is a possible delay, and a possible misunderstanding. Successfully running
services can be more complex at task than we expect, and this is why it is useful to
formalize them in an ITIL fashion.

@c **********************************************************************
@node Continual Service Improvement,  , Service Operation, Foundations
@subsection Continual Service Improvement

Continual improvement is quite self-explanatory. We are obviously
interested in learning from our mistakes and improving the quality and
efficiency by which we respond to service requests. But it is
necessary to think carefully about when and where to introduce this
aspect of management. How often should we revise out plans and change
procedures?  If this is too often, the overhead of managing the quality
becomes one of the main barriers to quality itself! Continual has to mean regular
on a time-scale that is representative for the service being provided, e.g.
reviews once per week, once per month? No one can tell you about your needs.
You have to decide this from local needs.

@c **********************************************************************
@node Tool Support,  , Foundations, ITIL past and present
@section Tool Support

In the field of tool support for IT Service Management accordant to
ITIL, various white papers and studies have been published. In
addition, there are papers available from BMC, HP, IBM and other
vendors that describe specific (commercial) solutions. Generally, the
market for tools is growing rapidly, since ITIL increasingly gains
attention especially in large and medium-size enterprises. Today, it
is already hard to keep track of the variety of functionalities
different tools provide. This makes it even more difficult to approach
this topic in a way satisfactory to the entire researchers', vendors'
and practitioners' community.

That is why this document follows a different approach: Instead of thinking
of ever new tools and computer-aided solutions for ITIL-compliant IT Service
Management, this book analyses how the existing and well-established
technologies used for traditional systems administration can
fit into an ITIL-driven IT management environment, and it guides
potential practitioners in integrating a respective tool suite -- namely
CFEngine -- with ITIL and its processes.

To avoid any misunderstanding: We do not argue that CFEngine --
originally invented for configuring distributed hosts -- may be
deployed as a comprehensive solution for automating ITIL, but what we
believe is CFEngine and its more recent innovations can @emph{bridge
the gap} between the technology of distributed systems management and
business-driven IT Service Management.
To make the case we must show:

@enumerate
@item How ITIL terminology relates to the terminology of CFEngine and hence
to a traditional system administrator's language, and
@item Which parts (processes and activities) of
ITIL can be (partially) supported by CFEngine, and how.
@end enumerate

These are the main goals of the subsequent chapters.



@c **********************************************************************
@node A meeting of mind-sets, Using CFEngine to implement ITIL objectives, ITIL past and present, Top
@chapter ITIL and CFEngine comparison

To summarize the results of the previous chapters, it can be said that
the goals of ITIL and the purpose of CFEngine are quite different:
ITIL gives recommendatory guidance in process- and service- oriented
IT Service Management, while CFEngine provides a powerful solution
framework for a variety of common network and systems administration
tasks. In other words:

@enumerate
@item The scope of ITIL is much broader than traditional systems administration, but: Portions of systems administration and configuration management tasks take place in the context of certain ITIL processes.

@item CFEngine was not designed to replace ITSM tools like trouble ticket systems (TTS), workflow management or CMDBs, but: in the more technical areas of IT Service Management, CFEngine is able to support ITIL processes in their activities.
@end enumerate

@image{scope2,10cm,,Scope of ITIL and CFEngine,png}

The goal of this document is to give an overview on how CFEngine can
be used to support selected IT Service Management tasks according to
ITIL.


@menu
* Which ITIL processes apply to CFEngine?::  
* ITIL terminology::            
@end menu

@c **********************************************************************
@node Which ITIL processes apply to CFEngine?, ITIL terminology, A meeting of mind-sets, A meeting of mind-sets
@section Which ITIL processes apply to CFEngine?

@image{itilfcaps,10cm,,FCAPS and ITIL,png}

In version 2, ITIL divides itself into @emph{service
support} and @emph{service delivery}.  For
instance, service support might mean having a number of CFEngine
experts who can diagnose problems, or who have sufficient knowledge
about CFEngine to solve problems using the software. It could also
mean having appropriate tools and mechanisms in place to carry out the
tasks. Service delivery is about how these people make their knowledge
available through formal processes, how available are they and how
much work can they cope with? CFEngine enables a few persons to
perform a lot of work very cheaply, but we should not forget to track our performance
and quality for the process of continual improvement.

Service support is composed of a number of issues:
@itemize
@item Incident management: collecting and dealing with incidents.
@item Problem management: root cause analysis and designing long term countermeasures.
@item Configuration management: maintaining information about hardware and software and
their interrelationships.
@item Change management: implementing major sequenced changes in the infrastructure.
@item Release management: planning and implementing major ``product'' changes.
@end itemize
Although the difference between change management and release
management is not completely clear in ITIL, we can think of a release
as a change in the nature of the service, while change management
deals with alterations possibly still within the scope of the same release.
Thus is release is a more major change.

Service delivery, on the other hand, is dissected as follows:
@itemize
@item Service Level Management
@item Problem management
@item Configuration management
@item Change management
@item Release management
@end itemize
These issues are somewhat clearer once we understand the usage of the
terms ``problem'', ``service'' and ``configuration''. Once again, it
is important that we don't mix up configuration management in ITIL
with configuration management as used in a Unix parlance.

The notion of system administration in the sense of Unix does not
exist in ITIL. In the world of business, reinvented through the eyes
of ITIL's mentors, system administration and all its functions are
wrapped in a model of service provision.


@menu
* Configuration Management CM::  
* Asset Management what is it used for?::  
* Change management::           
* Change management vs convergence::  
* Release management::          
* Incident and problem management::  
* Service Level Management SLM::  
@end menu

@c **********************************************************************
@node  Configuration Management CM, Asset Management what is it used for?, Which ITIL processes apply to CFEngine?, Which ITIL processes apply to CFEngine?
@subsection ITIL Configuration Management (CM)

Perhaps the most obvious example is the term configuration management.

@table @i
@item Configuration Management
The process (and life-cycle) responsible for maintaining information
about configuration items (CI) required to deliver an IT service,
including their relationships.
@end table

As we see, this is comparable to our intuitive idea of ``asset
management'', but with ``relationships'' between the items
included. ITIL also defines ``Asset Management'' as ``a process
responsible for tracking and reporting the value of financially valuable assets''
and is a component of ITIL Configuration Management.

In the CFEngine world, configuration management involves planning,
deciding, implementing (``base-lining'') and verifying (``auditing'')
the inventory. It also involves maintaining the security and privacy
of the data, so that only authorized changes can be made and private
assets are not made public.

In this document we shall try not to mix the ITIL concept with the
more prosaic system administration notion of a configuration which
includes the current state of software configuration on the
individual computers and routers in a network.

Since CFEngine is a completely distributed system that deals with
individual devices on a one-by-one basis, we must interpret this asset
management at two levels:

@itemize
@item The local assets of an individual device at the level of virtual
structures and containers within it: files, attributes, software packages,
virtual machines, processes etc. This is the traditional domain of automation
for CFEngine's autonomic agent.

@item The collective assets of a network of such devices.
@end itemize
Since a single host can be thought of as a network of assets connected
through virtual pathways, it really isn't such a huge leap to see the
whole network in a similar light. This is especially true when many of the
basic resources are already shared objects, such as shared storage.


@c *******************************************************************'
@node Asset Management what is it used for?, Change management, Configuration Management CM, Which ITIL processes apply to CFEngine?
@subsection CMDB Asset Management

Why bother to collect an inventory of this kind? Is it bureaucracy
gone mad, or do we need it for insurance purposes? Both of these
things are of course possibilities.

The data in an ITIL Configuration Management Database (CMDB) can be
used for planning the future and for knowing how to respond to
incidents, in other words for service level management (SLM) and for
capacity planning.  An organization needs to know what resources it
has to know whether its can deliver on its promises.
Moreover, for finance and insurance it is clearly a sound policy to have a database of
assets.

For continuity management, risk analysis and redundancy assessment we
need to know how much equipment is in use and how much can be brought
in at a moment's notice to solve a business problem.  These are a few
of the reasons why we need to keep track of assets.

@c ***********************************************************
@node Change management, Change management vs convergence, Asset Management what is it used for?, Which ITIL processes apply to CFEngine?
@subsection Change management in the enterprise

If we make changes to a technical installation, or even a business
process, this can affect the service that customers experience.
Major changes to service delivery are often written into service level
agreements since they could result in major disruptions.
Details of changes need to be known by a help-desk and service personnel.


The decision to make a change is more than a single person
should usually. It requires consultation at different levels
of process.  An advisory board for changes takes on this role,
whether it is an informal board that communicates electronically
or a physical committee ``with six or more legs and no brain''.

@c ***********************************************************
@node Change management vs convergence, Release management, Change management, Which ITIL processes apply to CFEngine?
@subsection Change management vs convergence

We should be especially careful here to decide what we mean by
change. ITIL assumes a traditional model of change management that
CFEngine does not need. ITIL's ideas apply to the management of
CFEngine's configuration, not the way in which CFEngine carries out its
work.

In traditional idea of change management you start by ``base-lining'' a
system, or establishing a known starting configuration. Then you
assume that things only change when you actively implement a change,
such as ``rolling out a new version'' or committing a release. This,
of course, is very optimistic.

In most cases all kinds of things change beyond our control. Items are
stolen, things get broken by accident and external circumstances
conspire to confound the order we would like to preserve. The idea
that only authorized people make changes is nonsense.

CFEngine takes a different view. It thinks that changes in
circumstances are part of the picture, as well as changes in inventory
and releases.  It deals with the idea of ``convergence''.  In this way
of thinking, the configuration details might be changing at random in
a quite unpredictable way, and it is our job to continuously monitor
and repair general dilapidation. Rather than assuming a constant state
in between changes, CFEngine assumes a constant ``ideal state'' or
@emph{goal} to be achieved between changes. An important thing to realize about including
changes of external circumstances is that you cannot ``roll back''
circumstances to an earlier state -- they are beyond our control.

@c ***********************************************************
@node Release management, Incident and problem management, Change management vs convergence, Which ITIL processes apply to CFEngine?
@subsection Release management

A @emph{release} is a collection of authorized changes to a system.
One part of Change Management is therefore @emph{Release Management}.
A release is generally a larger umbrella under which many smaller
changes are made.  It is major change.
Changes are assembled into @emph{releases} and then they are rolled out.

In fact release management, as described by ITIL, has nothing to do
with change management. It is rather about the management of
designing, testing and scheduling the release, i.e. everything to do with
the release process except the explicit implementation of it.
@emph{Deployment} or @emph{rollout} describe the physical movement of
configuration items as part of a release process.



@node Incident and problem management, Service Level Management SLM, Release management, Which ITIL processes apply to CFEngine?
@subsection Incident and problem management

ITIL distinguishes between @emph{incidents} and @emph{problems}. An incident is
an event that might be problematic, but in general would observe
incidents over some length of time and then diagnose @emph{problems} based
on this experience. 

@table @i
@item Incident
An event or occurrence that demands a response.
@end table

One goal of CFEngine is to plan pro-actively to handle incidents
automatically, thus taking them off the list of things to worry about.

@table @i
@item Problem
A pattern of consequence arising from certain incidents that is detrimental
to the system. It is often a negative trend that needs to be addressed.
@end table


Changes can introduce new incidents.
An integrated way to make the tracking of cause and effect easier is
clearly helpful. If we are the cause of our own problems, we are in
trouble!


@c ***********************************************************
@node Service Level Management SLM,  , Incident and problem management, Which ITIL processes apply to CFEngine?
@subsection Service Level Management (SLM)

Also loosely referred to as Quality of Service. This is the
process of making sure that Service Level Promises are kept,
or Service Level Agreements (SLA) are adhered to.
We must assess the impact of changes on the ability to deliver
on promises.


@node ITIL terminology,  , Which ITIL processes apply to CFEngine?, A meeting of mind-sets
@section ITIL terminology

Like many other areas of wishful standardization, ITIL elevates itself
to a state of importance by using multitude of acronyms and
specialized terms.  Not all of these are as intuitive as one might
hope for and many simply seem beyond necessity. However, to understand
the writing, we need to know a few of them and also understand how
they differ from similar terms in system administration and the world
of CFEngine. In the appendix, we list with comments about the most important
of these terms. The figure shows a scatter-plot of these terms.


@image{topic,10cm,,ITIL terminology,png}

@c ***********************************************************
@node Using CFEngine to implement ITIL objectives, Summary, A meeting of mind-sets, Top
@chapter Using CFEngine to implement ITIL objectives

How does CFEngine fit into the management of a service organization?
There are several ways:
@itemize
@item It offers a rapid detection and repair of faults that help to avoid formal incidents.
@item It simplifies the deployment (release) of services.
@item Allows resources to be understood and planned better.
@end itemize
These properties allow for greater @emph{predictability}
of system services and therefore they contribute to customer confidence.


@menu
* Infrastructure or management?::  
* How can CFEngine or promises help?::  
* What is maintenance?::        
* Incident Management vs Maintenance::  
* Rollout and installation::    
* Change Management in ITIL::   
* Release Management in ITIL::  
* Configuration version control and rollback::  
* Availability and Capacity Management::  
@end menu

@node Infrastructure or management?, How can CFEngine or promises help?, Using CFEngine to implement ITIL objectives, Using CFEngine to implement ITIL objectives
@section Infrastructure or management?

Any tool for assisting with change management lies somewhere between
ITIL's notion of change management and the infrastructure itself. It
must essentially be part of both (see figure). This applies
to CFEngine too. 


@image{cfinf,10cm,,CFEngine is both infrastructure and a part responsible for infrastructure.,png}


CFEngine can manage itself as well as other resources: itself, its
software, its policy and the resulting plans for the configuration of
the system. In other words, CFEngine is itself part of the infrastructure
that we might change.

@c ***********************************************************
@node How can CFEngine or promises help?, What is maintenance?, Infrastructure or management?, Using CFEngine to implement ITIL objectives
@section How can CFEngine or promises help an enterprise

@menu
* Traditions::                  
* Modelling of policy::         
* Uniformity::                  
@end menu

@c ***********************************************************
@node Traditions, Modelling of policy, How can CFEngine or promises help?, How can CFEngine or promises help?
@subsection Traditional IT Management

Traditional methods of managing IT infrastructure involve working from
crisis to crisis -- waiting for `incidents' to occur and then initiating fire
suppression responses or, if there is time, proactive changes. With CFEngine,
these can be combined and made into a management @emph{service}, with
continuous service quality.

CFEngine can assist with:
@enumerate
@item Maintenance assurance.
@item Reporting for auditing.
@item Change management.
@item Security verification.
@end enumerate

Promise theory comes with a couple of principles:
@enumerate
@item Separation of concerns.
@item Fundamental attention to autonomy of parts.
@end enumerate

@c ***********************************************************
@node Modelling of policy, Uniformity, Traditions, How can CFEngine or promises help?
@subsection Modelling policy

Other approaches to discussing organization talk about the separation
of concerns, so why is promise theory special?  Object Orientation
(OO) is an obvious example. Promise theory is in fact quite different to
object orientation (which is a misnomer).  

Object orientation asks users to model abstract classes (roles) long
before actual objects with these properties exist. It does not provide
a way to model the instantiated objects that later belong to those
classes. It is mainly a form of information structure
modelling. Object orientation models only abstract patterns, not
concrete organizations.

Promise theory on the other hand considers only actual existing objects
(which it calls agents) and makes no presumptions that any
two of these will be similar. Any patterns that might emerge can be
exploited, but they are not imposed at the outset. Promise theory's
insistence on autonomy of agents is an extreme viewpoint from which
any other can be built (just as atoms are a basic building block from which
any substance can be built) so there is no loss of generality by making
this assumption.

In other words, OO is a design methodology with a philosophy, whereas
promises are a model for an arbitrary existing system.

@node Uniformity,  , Modelling of policy, How can CFEngine or promises help?
@subsection Uniformity

The traditional production-line paradigm for management of IT systems
involves reducing the number of variations -- often simply making
all systems identical for mass-production. However, as quoted at the
beginning of chapter 2, the purpose of advanced technology is to
enable us to cope with variation. CFEngine makes managing variations simple. 
Some organizations might simply want to have a uniform configuration on
all their hardware, but what does this mean if the basic hardware is
different?

In CFEngine we understand that ``similar'' should be based on how
systems behave not what their disk images look like. Two systems that
make the same promises ought to behave in the same way, if the promises
are at a high enough level. But what if two different operating systems
promised to never have a file called @code{/etc/passwd}? A windows machine
would not care too much, but a Unix system would be paralyzed.

Promises and system configuration are related: configuration affects
behaviour and behaviour is what we promise.  Clearly we cannot expect
very high level promises to be simply translated into configurations
however. The fact that we make promises about system configuration
says nothing certain about the promise that results from changing
it. That depends on many other factors. Thus we must be careful to think about 
what a promise means.

@table @i
@item Fundamental assumption
The basic assumption of configuration management is that a specific
configuration determines the resulting behaviour of a system. This
assumption is completely unproven, and is sometimes obviously false.
At best there is a correlation between configuration and
behaviour. This is what makes IT management challenging. The things we
can change do not necessarily give us the control we would like.
@end table


@c ***********************************************************
@node What is maintenance?, Incident Management vs Maintenance, How can CFEngine or promises help?, Using CFEngine to implement ITIL objectives
@section What is maintenance?

Maintenance is a process that ITIL does not formally spend any time
on explicitly, but it is central to real-world quality control.

Imagine that you decide to paint your house. Release 1 is going to be
white and it is going to last for 6 years. Then release 2 is going to
be pink. We manage our painting service and produce release
1 with all of the care and quality we expect. Job done? No.

It would be wrong for us to assume that the house will stay this fine
colour for 6 years. Wind, rain and sunshine will spoil the paint over
time and we shall need to touch up and even repaint certain areas in
white to maintain release 1 for the full six years. Then when it is time
for release 2, the same kind of maintenance will be required for that too.

Unless we read between the lines, it would seem that ITIL's answer to
this is to wait for a crisis to take place (an incident). We then
mobilize some kind of response team. But how serious an incident do we
require and what kind of incident response is required? A graffiti artist?
A lightening strike? A bird anoints the paint-work? CFEngine is
like the gardener who patrols the grounds constantly plucking weeds,
before the flower beds are overrun. Call it continual improvement if
you like: the important thing is that the process your be pro-active
and not too expensive.

Maintenance is necessary because we do not control all of the
changes that take place in a system. There is always some kind of
``weather'' that we have to work against. CFEngine is about this
process of Maintenance. We call it ``convergence'' to the ideal state,
where the ideal state is the specified version release.
Keep this in mind as you read about ITIL change management.

@c ***********************************************************
@node Incident Management vs Maintenance, Rollout and installation, What is maintenance?, Using CFEngine to implement ITIL objectives
@section Incident Management vs Maintenance

CFEngine employs the idea of continual maintenance (we paint the fence
on a regular basis to protect it). ITIL, on the other hand, moves from
release to release (this year we paint the fence red, next year green)
and does not recognize the effect of gradual entropic decay of state
(the fence's colour fades gradually due to the harsh
environment). Instead ITIL deals with events (graffiti and tagging of
the fence) which must be corrected. While it is true that these
incidents are maintenance, the repairs are more costly to initiate if
they occur as exceptional events than if we are used to repainting the
fence on a regular basis.


@image{cf_evm,10cm,,An exemplary Event Management process on the basis of ITIL V3,png}

The figures above show ITIL processes for the handling of
events and incidents. They show the aspects of dealing with events that are
mainly human oriented, and those events in shaded boxes that can be automated
using CFEngine.

In the figure above we see that there must be a basic monitor at
the top of the process chain which is responsible for observing
events. This fits well with the view of promise theory in which a
neutral observer is required to measure the state of different
component agents in the system. Not all events are necessarily
relevant or interesting so we can filter these based on a
policy. CFEngine's event monitors come from two sources: cfagent (for
monitoring the state of promises which are being managed - e.g. the
proverbial colour of the fence) and cfenvd (for passively monitoring
the environment - e.g. the brightness of the sunshine or the amount of
rainfall impacting on the fence). 

@itemize
@item CFEngine filters events through its
class interface. All events observed in CFEngine are @emph{classified}
and made available to the environment.

@item CFEngine logs events by routing messages to email or to syslog (by asking
@code{inform=true} or @code{syslog=true} or @code{audit=true}).

@item The daemon @code{cfenvd} auto-correlates events. The tool @code{cfbrain}
will cross correlate events, further classifying the outcomes as part of the
environment.

@item Events can be triggered by attaching promises to event-driven classes
in the cfagent configuration. e.g.

@smallexample

processes:

  www_in_high_anomaly::

    ``apache'' signal=term

alerts:

  www_in_high_anomaly::

    ShowState(www.in)

@end smallexample
For more devastating incidents, we can arrange for more information to
be output.  An incident is really only an event of some special
significance.  Diagnosing an incident requires either human
intervention or pre-cached insight on the part of the promises we
make. If we can make a specific promise then the diagnosis that this promise
has not been kept can easily be turned into a specific repair. For example,

We might note a sudden burst of smtp traffic, or a sudden decrease in free disk space.
These events can be anticipated if one knows a benign cause, such as email
was shutdown for maintenance, or the host is a new mail-server that has never seen
traffic before.

@end itemize

@image{cf_im,10cm,,An exemplary Incident Management process on the basis of ITIL V3,png}

@c ***********************************************************
@node Rollout and installation, Change Management in ITIL, Incident Management vs Maintenance, Using CFEngine to implement ITIL objectives
@section Rollout and installation

When setting up hosts, ITIL actually makes a techical recommendation.
This is unusual for ITIL as it generally does not get mixed up in the
details of management, only the processes. ITIL recommends
``base-lining'' systems from a @emph{gold server}, i.e. a system that is
thought to be ``perfect'' enough to act as a model for all other
systems. Once a server has been base-lined from the golden image,
various customizations can be made relative to this known state. ITIL
sees this as a way of achieving consistency.

We believe that ITIL exceeds its technical competence in making this a
recommendation. True enough, this has traditionally been a way of
performing a rollout, but the approach has been superceded by better
technology. The gold server approach is not the recommended CFEngine
way. In fact a golden-image approach wastes a fundamental flexibility
that CFEngine offers, namely the possibility to allow @emph{variations} (see
the quote by Alvin Toffler at the start of chapter 2).

When we baseline a system from a gold-server, we are planning to make all
hosts basically the same. However, this is neither necessary nor cost-saving
if you use CFEngine.

CFEngine places no restrictions on the approach used to roll out
hosts.  Rather than requiring you to start from a known state, it
allows you to specify the @emph{final} state for any initial
state. This means you can migrate hosts gradually to a policy state
without having to reinstall them.  We can consider the end result of a
CFEngine policy process to be ``the release''.  In CFEngine this is
equivalent to a sufficiently comprehensive configuration policy.

The message here is that CFEngine allows you to achieve predictable
results without the need for a gold server. Nevertheless, it is helpful
to begin a system based on a reliable substrate. It is like making a good
sandwich: it helps to have a perfect piece of bread to build on, but it's what
you put on top that is most important. You just need to know what you are starting
with, and then most things can be fixed to satisfaction.
We recommend:

@itemize
@item Start with some kind of standard image to start (a predictable substrate).

It is does not necessarily matter what it is as long as it behaves predictably.
e.g. install from known DVD, or install from net-boot or even from a gold server.

@item Customize the basic working system using CFEngine.
There are two possible approaches to this:

i) Copy constant ``gold'' overlays or patches into place from a trusted source
to customize the system.

@itemize
@item Add more operating system packages.
@item Insert special files (config, data etc).
@item Run post-processing scripts.
@end itemize

ii) Edit system directly with CFEngine
@itemize
@item Documented automatically by cfagent promises.
@item Can always customize after that too (phase 3)!
@end itemize
@end itemize



@menu
* Customize by constant fixed overlay::  
* Overlay an expandable template::  
* Direct customization::        
@end menu

@c ***********************************************************
@node Customize by constant fixed overlay, Overlay an expandable template, Rollout and installation, Rollout and installation
@subsection Customize by constant/fixed ``gold'' overlay

The first alternative is to install a fixed patch to a system
from a known gold-server.
The basic pattern is this:


@smallexample
copy:

  /source/file 

      dest=/dest/file
      server=gold_server
@end smallexample

In this example, we simply install a new file into a known location.
This is the simplest way of customizing a host, but it lacks flexibility.

@c ***********************************************************
@node Overlay an expandable template, Direct customization, Customize by constant fixed overlay, Rollout and installation
@subsection Overlay an expandable template with CFEngine

A more sophisticated approach is to download a parameterized template
from a repository or gold server. This template contains context
dependent variables that can be expanded in situ by CFEngine.  There
are two stages to this: first we copy the template to a temporary
location, then we edit the final file location, insert the template
and expand its variables. By following this procedure, the result
satisfies CFEngine's principles of @emph{convergence}.


@smallexample
copy:

/source/file 
      dest=/tmp/file
      server=gold_server

editfiles:

@{ /dest/file

EmptyEntireFilePlease
InsertFile ``/tmp/file''
ExpandVariables 
@}
@end smallexample


@c ***********************************************************
@node Direct customization,  , Overlay an expandable template, Rollout and installation
@subsection Direct customization by CFEngine

A final approach to customization is to apply direct
editing operations to implement the required customization.

@smallexample
editfiles:

@{ /dest/file

ReplaceAll ``X'' With ``Y''
AppendIfNoSuchLine ``ABC''
@}
@end smallexample

This approach is useful for small corrections, that require 
unsophisticated editing, but it becomes quickly cumbersome
for more complex tasks.


@node Change Management in ITIL, Release Management in ITIL, Rollout and installation, Using CFEngine to implement ITIL objectives
@section Change Management in ITIL

ITIL proposes that there should be an integrated approach to change and
configuration management. Clearly changes to a system result in new 
configurations. However, changes can also be unplanned involuntary
faults (ITIL discusses these as @emph{incidents}).


ITIL does not want unplanned changes, however we know that they happen. 
CFEngine does not elevate deviations from policy to the level of an
incident normally, it simply fixes problems immediately. However, we do not
alway have enough information about changes to allow CFEngine to make repairs,
so we need a way of monitoring for unexpected change.


Change management in CFEngine is a subtle topic, because CFEngine does
not fully subscribe to the model of change that ITIL does. In CFEngine's
view of the world, all changes are changes no matter how or why they
occur.  In ITIL's world view, there are planned changes, there are
releases and there are ``incidents''. 

ITIL therefore distinguishes between planned and unplanned changes that
affect service delivery. CFEngine on the other hand cares only about
what promises have been made about the system and whether or not these
have been kept. 

CFEngine can detect changes because it effectively performs a constant
audit of the system's promises. We should understand CFEngine's change
detection in two ways: changes that impact the performance or quality
of services

@itemize
@item with respect to the quality of the system configuration service (i.e. CFEngine's service)
@item with respect to the quality of services supported by the system configurations (e.g. other services
like web services)
@end itemize
To CFEngine, changes only matter if they impact the promises that have
been codified as policy.  Even events that CFEngine calls ``anomalies'',
detected and classified continuously, are only considered
interesting if policy determines them to be restricted, thus every
single state change can be considered either ``within tolerances''
(insignificant) or ``out of tolerance'' (significant). ITIL is only a
heuristic set of guidelines and is not technically sophisticated
enough to be able to make this kind of distinction.

Let's make an approximate mapping between ITIL concepts and CFEngine change
and the comment critically on it.

@table @i
@item ITIL
     CFEngine
@item Incident 
Promise not kept
@item Change   
Configuration version/content update
@item Release  
Policy change
@end table

@menu
* Software packaging::          
* Rollback or remediation::     
* Monitoring file changes::     
* Hashes and Message Digests::  
* Computing hashes::            
* Neighbourhood watch and tampering::  
@end menu

@c ***********************************************************
@node Software packaging, Rollback or remediation, Change Management in ITIL, Change Management in ITIL
@subsection Software packaging in ITIL

ITIL considers releases to be entire integrated systems that are
versioned. Most operating systems work at a smaller level of
granularity than this.  Software version control using package
managers to version individual software packages. Although such
package managers resolve dependencies, they do not version
entire conglomerates of software. Software comes in large
packages for two main reasons:

@itemize
@item Operating system installation (all or nothing).
@item Functional role adaptation (specialized workstation).
@end itemize
Different organizational roles require different ITIL services
to support them, and hence different software to deliver them.

CFEngine deals with versioned data management in two ways:
@itemize
@item File copying from master source (by date-stamp or checksum).
@item Package installation and verification (using local package managers).
@end itemize
Package managers handle the installation and update of packages
easily, but they do not always add institutional adaptational
control in a way that can be tied into a classification of
hosts in an organization's network. CFEngine can use its
classification of hosts to customize further. We simply
attach relevant clusters of packages to different classes
of host to ensure that specific workstations are
properly adapted to service their tasks.

Not all software comes in operating system (vendor/provider)
approved packages, but CFEngine can also handle software
that is zipped, tar-ed or bundled in any other manner.

The following example policies illustrates some of the @code{copy} rule type's capabilities,
 including some of the options we just considered:


@smallexample

control:
    DefaultCopyType = ( mtime )
    SplayTime = ( 15 )
    sourcehost = ( source.CFEngine.org )

copy:
#   Copy dat/doc files if not too big
    /usr/local/data dest=/archive/data
      include=*.dat include=*.doc exclude=test.*
      recurse=inf backup=false size<500m

#   Retrieve configuration file from master
    /depot/hosts.deny server=$(sourcehost)
      dest=/etc/hosts.deny owner=root group=0 mode=644
      backup=off force=on timestamps=keep

#   Transmit shadow password file encrypted
   /depot/shadow server=\$(sourcehost) dest=/etc/shadow 
      owner=0 group=0 mode=600 encrypt=true
@end smallexample


The first rule specifies that @file{.dat} and @file{.doc} files within the
@file{/usr/local/data} directory tree be copied to @file{/archive/data},
provided that the source files have been modified more recently then
their counterpart in the target directory and that they are smaller than 500 MB. In addition, files having
the name @file{test} are also excluded. Existing files will be overwritten without being saved.

The second rule unconditionally replaces the local
@file{/etc/hosts.deny} file with one from the system
@code{source.CFEngine.org}, retaining the timestamps from the source
file. This rule also specifies the ownership and mode for the target
file.

The third rule is similar to the second one, retrieving another file
from the same remote system. In this case, however, the file will be
copied only when the remote file is more recent than the local
copy. When the file is copied, the previous version will be retained,
and the file contents will be encrypted at it is transmitted across
the network.


CFEngine can also automate software package management and
installation.  Policies for these items are specified in the @code{packages} stanza. Here are some examples:


@smallexample

control:    # Define package manager \& install command
  linux::  DefaultPkgMgr = ( rpm )
  redhat:: RPMInstallCommand = ( "/usr/sbin/up2date %s" )
  suse::   RPMInstallCommand = ( "/usr/sbin/yast2 -i %s" ) 

packages:
    nagios version=2.4 cmp=ge
    pstree action=install
@end smallexample


The settings in the @code{control} section specify the package
management software that is in use as well as the command used to
install a software package. These directives illustrate the use of
operating system-based classes within policies for defining a
different installation command for different Linux distributions.

In the @code{packages} stanza, the first rule checks whether Nagios is
installed.  A warning will be generated if the package is not present
at all or if the installed version is earlier than version 2.4. The
second rule checks for the @code{pstree} package, and installs it if
it is not present on the system.

The following parameterized method-promise installs
its first argument in the prefixed location given by the second
argument. It collects the tar file, unpacks it, configures and
compiles it, then tidies its files.


@smallexample

#
# Build GNU sources and install
#
 
control:

   actionsequence = ( methods )

methods:

   InstallTar(CFEngine-2.1.0b7,/local/gnu)

      action=cf.install
      returnvars=null
      returnclasses=null
      server=localhost

@end smallexample


We must install the method in the trusted modules directory (normally
@code{/var/cfengine/modules} or WORKDIR/modules).


@smallexample

#
# cf.install
#

control:

 MethodName       = ( InstallTar )
 MethodParameters = ( filename prefix )
 path = ( /usr/local/gnu/bin )
 TrustedWorkDir = ( /tmp )
 TrustedSources = ( /depot )
 TrustedSourceServer = ( localhost )

 actionsequence = ( copy editfiles shellcommands tidy )

copy:

 $(TrustedSources)/$(filename).tar.gz 
    dest=$(TrustedWorkDir)/$(filename).tar.gz 
    server=$(TrustedSourceServer)

shellcommands:

 "$(path)/tar zxf $(filename).tar.gz"  chdir=$(TrustedWorkDir)

 "$(TrustedWorkDir)/$(filename)/configure --prefix=$(prefix)" 
    chdir=$(TrustedWorkDir)/$(filename)
    define=okay

 okay::

 "$(path)/make" 
     chdir=$(TrustedWorkDir)/$(filename)

tidy:

  $(TrustedWorkDir) pattern=$(filename) r=inf rmdirs=true age=0

@end smallexample

@c ***********************************************************
@node Rollback or remediation, Monitoring file changes, Software packaging, Change Management in ITIL
@subsection Rollback or remediation

The ability to go back to an earlier ``release'' or state is often
referred to as rollback. ITIL calls it remediation. The notion is
closely connected with process management, and both ITIL and
traditional management techniques value this by default. It is assumed
practice.

CFEngine does not encourage rollback however. Why not? Because it
required destructive intervention and CFEngine's model is based on
on-the-fly change. To go back to a previous state, a system must be
stopped, reinitialized (perhaps from backup) and restarted. This
requires service to stop and all run-time state is lost.

CFEngine's approach to this would be to revert @emph{policy} to its
previous state. The system would then roll into its desired state (as
if going forwards). Nothing would be restored from separate backup
media (see figure).

@image{roll-forward,15cm,,Move from one fixed point to another and back.,png}

The difference here is the assumption about how and when changes
occur.  A sequence of step by step transitions sounds innocent, but it
is unstable to unexpected changes. ITIL and many other change
management models assumes that no unauthorized changes occur between
releases.  If they do, they are handled as incidents. By separating
releases from incidental changes, we get led into thinking that
we can in fact revert by destructive intervention.

In fact reversion has inevitable consequences. We must make a choice.

@itemize
@item Revert entire state, except we lose runtime state.

In this case, we essential revert the entire system from a back up of
its saved state. (Some virtual machines can save runtime state for
resumption, but this can become stale, e.g. for network connections,
as it is meaningless to rollback part of a dialogue.) This operation
results in catastrophic change.

@item Revert managed state, on the fly.

This is CFEngine's default behaviour. To go back to a previous state,
simply change the policy back to a previous version. This will not
necessarily revert the entire state of the system, but everything that
is covered by policy will be reverted.
@end itemize

Some tools allow you to rollback without reverting from
backup. CFEngine disallows this on principle as it requires
human judgement to perform correctly. It cannot be automated without
uncertain results. In fact CFEngine
retains the necessary information to allow managed changes to be
reversed to some extent. The point however is that one can only
guarantee the content of managed objects, so simply reversing a change
will not necessarily take us back to the same state -- so we consider this
to be fundamentally too risky.

@c ***********************************************************
@node  Monitoring file changes, Hashes and Message Digests, Rollback or remediation, Change Management in ITIL
@subsection Monitoring file changes

CFEngine can monitor absolute and relative states
of a system. A simple way to measure relative change is
to use a database of checksums. 

@smallexample
control:

  ChecksumUpdates = ( true )
  ChecksumPurge   = ( true )

files:

  /my/important/files    

        recurse=inf
        checksum=md5
        owner=root,daemon
        group=0,1,4
@end smallexample


Change monitoring is about detecting when stored data, or other
measurable aspects of a computer system change. A change detection
system is not normally concerned with the reason for a change, but if
you are monitoring for change then we shall take it for granted
somehow that you are expecting to find changes that you didn't plan
for yourself.

@c ***********************************************************
@node Hashes and Message Digests, Computing hashes, Monitoring file changes, Change Management in ITIL
@subsection Hashes and Message Digests

The most important bulk of information on a computer is its filesystem
data. Change detection for filesystems uses a technique made famous in
the program Tripwire, which collects a ``snapshot" of the system in the
form of a database of file checksums (cryptographic hashes) and
permissions and rechecked the system against this database at regular
intervals. Tripwire examines files, and looks for change in their
contents or their attributes. This is a very simple (even simplistic)
view of change. If a legitimate change is made to the system, such a
system responds to this as a potential threat. Databases must then be
altered, or rebuilt.

A cryptographic hash (also called a @i{digest}) is an algorithm that
reads (digests) a file and computes a single number (the hash value)
that is based on the contents. If so much as a single bit in the file
changes then the value of the hash will change. You can compute
hash values manually, for example:

@smallexample

host$ openssl md5 CFEngine-2.2.4a.tar.gz
MD5(CFEngine-2.2.4a.tar.gz)= 6d2b31c4814354c65cbf780522ba6661

@end smallexample

There are several kinds of hash function. The most common ones are MD5
and SHA1. Recently both of the algorithms that create these hashes
have been superceded by the newer SHA2. CFEngine supports MD5 and SHA1
and it will support SHA2 as soon as the OpenSSL library supports an
interface to the new algorithm.

@c ***********************************************************
@node Computing hashes, Neighbourhood watch and tampering, Hashes and Message Digests, Change Management in ITIL
@subsection Computing hashes or digests

CFEngine has adopted something like the Tripwire model, but with a few
provisoes. Tripwire assumes that all change is unauthorized (it makes
an incident out of any observed change). CFEngine cannot reasonably take this viewpoint.  CFEngine expects
systems to change dynamically, so it allows users to define a policy
for what changes are considered to be okay.

Integrity checks on files whose contents are supposed to be static are
a good way to detect tampering with the system, from whatever
source. Running MD5 or SHA1 checksums of files regularly provides us
with a way of determining even the smallest changes to file contents.

To use the checksum based change detection we first ask CFEngine to
collect MD5 hash data for specified files. Here is an excerpt from a
CFEngine configuration program that would check the /usr/local
filesystem for file changes. Note that it excludes files such as log
files that we therefore allow to change (log files are supposed to
change):

@smallexample
files:

  /usr/local owner=root,bin,man
             mode=o-w          # check permissions separately 
             r=inf 
             checksum=best     # switch on change detection
             action=warnall 
             ignore=logs 
             exclude=*.log

  # repeat for other files or directories

@end smallexample

The first time we run this, CFEngine collects data and treats all files
as ``unchanged''. It builds a database of the checksums. The next time the
rule is checked, cfagent recomputes the checksums and compares the new values
to the `reference' values stored in the database. If no change has occurred, 
the two should match. If they differ, then the file as changed and a warning
is issued.

@smallexample
cf:nexus: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
cf:nexus: SECURITY ALERT: Checksum (md5) for /etc/passwd changed!
cf:nexus: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
@end smallexample

This message is designed to be visible. If you do not want the embracing
rows of `!' characters, then this control directive turns them off:

@smallexample
control:

 Exclamation  = ( off )
@end smallexample
The next question to ask is: what happens if the change that was
detected is actually okay (which is almost always the case in practice). 
If you activate this option:
@smallexample
control:

 ChecksumUpdates = ( on )
@end smallexample
Then, as soon as a change has been detected, the database is updated
and the message will not be repeated.  If this is set to @code{off},
which is the default, then warning messages will be printed each time
the rule is checked.

New files are automatically detected, as they are not in the database.
If you want to be notified when files are deleted, then set the option

@smallexample
control:

 ChecksumPurge = ( on )
@end smallexample

@c ***********************************************************
@node Neighbourhood watch and tampering,  , Computing hashes, Change Management in ITIL
@subsection Neighbourhood watch and tampering

Message digests are supposed to be unbreakable, tamperproof
technologies, but of course everything can be broken by a sufficiently
determined attacker. Suppose someone wanted to edit a file and alter
the CFEngine checksum database to cover their tracks. If they had
broken into your system, this is potentially easy to do. How can we
detect whether this has happened or not?

A simple solution to this problem is to use another checksum-based
operation to copy the database to a completely different host. By using
a copy operation based on a checksum value, we can also remotely detect
a change in the checksum database itself. 

Consider the following code:

@smallexample
# Neighbourhood watch

control:
          
 allpeers = ( 
            SelectPartitionNeighbours(/path/hostlist,\#,random,4) 
            )
          
copy:

     /var/cfengine/checksum\_digests.db

                       dest=/safekeep/chkdb_$(this) 
                       type=checksum
                       server=$(allpeers)
                       inform=true          # warn of copy
                       backup=timestamp
                       define=tampering

alert:

 tampering::

      'Digest tampering detected on a peer'   
@end smallexample


It works by building a list of neighbours for each host. The function
@smallexample
SelectPartitionNeighbours
@end smallexample
can be used for this. Using a file which
contains a list of all hosts running CFEngine (e.g. the @code{cfrun.hosts} file),
we create a list of hosts to copy databases it from. Each host in the
network therefore takes on the responsibility to watch over its neighbours.

The copy rule attempts to copy the database to some file in a safekeeping
directory. We label the destination file with @code{$(this)} which becomes
the name of the server from which the file was collected. Finally, we backup
any successful copies using a timestamp to retain a complete record of all changes
on the remote host. Each time a change is detected, a copy will be kept of the
old. The rule contains triggers to issue alerts and warnings also just to make
sure the message will be heard.

In theory, all four neighbours should signal this change. If an attacker
had detailed knowledge of the system, he or she might be able to subvert
one or two of these before the change was detected, but it is unlikely that
all four could be covered up. At any rate, this approach maximizes the
chances of change detection.

Finally, in order to make this copy, you must, of course, grant access to the
database in @code{cfservd.conf}.


@smallexample
# cfservd.conf

admit:

any::

  /var/cfengine/checksum_digests.db  mydomain.tld
@end smallexample


Let us now consider what happens if an attacker changes a file an edits
the checksum database. Each of the four hosts that has been designated
a neighbour will attempt to update their own copy of the database. If the
database has been tampered with, they will detect a change in the md5
checksums of the remote copy versus the original. The file will therefore
be copied.

It is not a big problem that others have a copy of your checksum
database.  They cannot see the contents of your files from this.  A
possibly greater problem is that this configuration will unleash an
avalanche of messages if a change is detected. This makes messages visible at least.




@c ***********************************************************
@node Release Management in ITIL, Configuration version control and rollback, Change Management in ITIL, Using CFEngine to implement ITIL objectives
@section Release Management in ITIL

Release management, as defined by ITIL (section 9 of BS15000-2), is a
management function rather than a machine implementation
operation. It includes all aspects of designing, planning and scheduling
changes, but does not include the implementation.

CFEngine can help with the final stages of software release
management, namely deployment of software components and
configuration. However, the bulk of this item concerns the human
process of decision-making.

@itemize
@item Creating a schedule and policy for releases.
@item Acquiring of completing the components for release.
@item Assigning roles for responsibility.
@item Labelling release items uniquely for tracking.
@item Documentation updates.
@item Testing prior to release.
@end itemize
CFEngine is not a tool for assisting in this kind of process.  Some
kind of process planning tool and revision control system could work
for this.

CFEngine has features that can be considered in the context of this
work, however.

@itemize
@item packages

@item files

@item copy

@end itemize

ITIL frequently works with the idea of a @emph{baseline state}
While CFEngine has no problem working with the idea of a baseline configuration,
it is designed to exceed this assumption of maintenance from release to release.
ITIL does not adequately address the need for on-the-fly maintenance; it only
models large-jump changes, not error corrections. CFEngine, on the other hand, makes
no distinction between a large and a small change, thus users of CFEngine must make
a value judgement about the nature of such changes.


@c ***********************************************************
@node Configuration version control and rollback, Availability and Capacity Management, Release Management in ITIL, Using CFEngine to implement ITIL objectives
@section Version control and rollback



CFEngine does not provide specific tools for versioning configuration
specifications. It is rather recommended to use a tool such as subversion
for this.

Subversion maintains its own revision numbers that are not
visible to CFEngine however. 
It is useful to be able to refer to version numbers also
in CFEngine. From software release 2.2.2 a version string
can be added to files as follows:
@smallexample
control:

cfinputs_version = ( 1.2.3 )
Auditing   = ( on )

@end smallexample
This
defines the version number of a set of configuration files
which is referred to in auditing and error messages.


When CFEngine saves the current
version of a file that it is modifying or replacing, by default such
files are given a new extension and remain within the same directory
which they were encountered. Alternatively, one can specify a
repository directory to which such files can be moved instead. The
repository location is specified in the @code{control} section:
@smallexample
control:
    Repository = ( /var/spool/CFEngine )
@end smallexample
Files moved to the repository are given names reflecting their full path, with slashes replaced
by underscore characters. For some, this creates a clearer overview of the 
changes that have occurred.

The repository is used by @code{disable}, @code{editfiles}, @code{links}, and @code{copy} rule types;
@code{copy} and @code{disable} allow you to override repository use or to specify an alternate
repository directory via their @code{repository} option.


You should never edit the production version of a policy directly, but rather edit a
separate development area and publish the changes once tested. The ITIL change management
process is applicable to this human change (much more relevant that the machine changes
made by CFEngine itself.).


@menu
* Delegating responsibility to multiple groups::  
@end menu

@c ***********************************************************
@node Delegating responsibility to multiple groups,  , Configuration version control and rollback, Configuration version control and rollback
@subsection Delegating responsibility

CFEngine has no meta-access control mechanism which can decide who may
write policy rules. To create such a mechanism, there would have to be
a monitor which could identify users, and an authority mechanism that
would disallow certain users to write rules of certain types about
certain objects on certain hosts. Clearly it is @emph{possible}
to create such a system, but it would be both technically
difficult, very cumbersome to use and would add a whole new level
of complexity to policy and potential error to the configuration process.

To keep matters as simple as possible, CFEngine avoids this and
proposes a different approach. Promise theory allows us to model the
security implications of this (see the figure of the bow-tie
structure). A simple method of delegating is the following.

@enumerate
@item Delegate responsibility for different issues to admin teams 1,2,3, etc.
@item Make each of these teams responsible for version control of their own
configuration rules.
@item Make an intermediate agent responsible for collating and vetting the rules, checking for
irregularities and conflicts. This agent must promise to disallow rules by
one team that are the responsibility of another team. The agent could be a
layer of software, but a cheaper and more manageable solution is the make this
another group of one or more humans.

@item Make the resulting collated configuration version controlled. Publish
approved promises for all hosts to download from a trusted source.


@end enumerate

A review procedure for policy promises is a good
solution if you want to delegate responsibility for different parts of
a policy to different sources. Human judgement is irreplaceable, and tools
can be added to make conflicts easier to detect.

Promise theory underlines that, if a host of computing device accepts
policy from any source, then it is alone and entirely responsible for
this decision. The ultimate responsibility for the published version
policy is the vetting agent. This creates a shallow hierarchy, but
there is no reason why this formal body could not be comprised of
representatives from the multiple teams.

@image{delegate,10cm,,Delegation of responsibility requires vetting access,png}


@c ***********************************************************
@node Availability and Capacity Management,  , Configuration version control and rollback, Using CFEngine to implement ITIL objectives
@section Availability and Capacity Management

CFEngine records all manner of information about the behaviour of computers during
its efforts to keep promises. These data offer the potential of mining for building
up a picture of the behaviour of an entire datacentre or organization, perhaps even
multiple domains.

CFEngine's environment daemon further collects patterns of environmental influence
of hosts in a resource non-intensive manner.
These data contain much information to enable capacity planning.

We should add a warning however. Capacity planning requires a considerable
amount of data and analysis, as well as a sound and critical judgement of the
data. Resource and performance management are such complex issues that
no simple recipe or checklist can replace the judgement of an experienced
engineer. However, CFEngine can supply data to such an engineer.

@enumerate
@item Performance measurements (@code{cfshow -p}) allow the average throughput of a server in terms
of time to completion of service. If service times are too long, this is an indication
(but not proof) that hardware should be upgraded.

@item Activity levels are graphed per service. These indicate the level of traffic
coming into the different servers. Evidence of a ceiling limit on the throughput (clipping
in the time-series) can show insufficient throughput.

@item Distribution graphs of fluctuations about the mean can also show evidence
of ceiling limits. Asymmetric distributions show when the majority of
service requests tend to bunch at a high level (probable stress on
server) or at a low level (over dimensioned server).
@end enumerate

The level of technical understanding to make sound judgements based on
these data goes somewhat beyond the scope of this document. This
motivates us to create better tools for CFEngine that can make these
analyses more accessible to users. However, this must be deferred for another
occasion.


@c ***********************************************************
@node Summary, ITIL glossary, Using CFEngine to implement ITIL objectives, Top
@chapter Summary

We have described the basics of CFEngine and ITIL and shown a number
of areas where the two can be integrated.


@itemize
@item CFEngine users can benefit from the disciplines that ITIL brings.
@item ITIL can benefit from the predictability that CFEngine brings.
@end itemize





@menu
* How we wrote this document::  
* Road-map for adoption::       
@end menu

@c ***********************************************************
@node How we wrote this document, Road-map for adoption, Summary, Summary
@section How we wrote this document, Promise concepts voluntary cooperation, Summary, Summary


So, if ITIL is so great, did we use it to manage the process of
writing this document?  Authoring a document and authoring a policy
have much in common, so let us spend a moment to examine the process
of checks and balances that we have used to produce this text.

The answer to our question is both yes and no, and while this might
sound rather unhelpful, we suggest that it is in fact a significant
answer; indeed it is the @emph{right} answer in response to any
question about best practices because such recipes must always be
applied to a specific context.

There are sensible and ridiculous ways to implement a set of
recommendations. ITIL users should expect to adapt its generalized
ideas to each set of special circumstances. To do this here, we have
used the parts of ITIL that make particular sense for authoring, and
we have also used CFEngine's model of promises or voluntary
cooperation to understand how to implement them.

For example, ITIL suggests forming committees for discussing and
deciding change.  A committee is a cumbersome device when the total
number of people involved in the entire process is two. Nevertheless,
the role of the committee is relevant (i.e. the promises it makes to
bring the process to completion), and this is where promise theory
helps us to make sense of the ``dumb rules''. We have multiple opinions
and multiple pairs of eyes for quality control as well as for inspiration.

@menu
* ITIL concepts for authoring::  
* Promise concepts voluntary cooperation::  
@end menu

@node ITIL concepts for authoring, Promise concepts voluntary cooperation, How we wrote this document, How we wrote this document
@subsection ITIL concepts for authoring, Promise concepts voluntary cooperation, Summary, Summary

Several parts of ITIL are quite relevant to authoring.

@itemize
@item @emph{Service management.} A document provides an information service to its clients (the readers).
It promises to be accurate to within reasonable limits.

@item @emph{Release management.} Each version of our document can be considered a release
which undergoes a continual improvement cycle, constantly being evaluated and
changed in accordance with events and incidents that occur.

@item @emph{Incidents.} An incident is something that impacts on the service. An incident
could be the discovery of an error in the text. It could be a disagreement between
the authors or a misunderstanding on the part of the reader. There have been many incidental
changes based on discussions in our teams.

@item @emph{Impact.} The impact of the incident is the potential damage caused by the incident,
or the usefulness of the discovery. Incidents are not necessarily negative events. They
can be events which point out improvements.

@item @emph{Request for change.} One of the authors asks to make changes to the text.

@item @emph{Change management.} Each identified change can be evaluated for its potential
impact (benefit or confusion). If there are many changes to be made, priority can be
assigned to them. When should the changes be implemented?

@end itemize

@c ***********************************************************
@node Promise concepts voluntary cooperation,  , ITIL concepts for authoring, How we wrote this document
@subsection Promising voluntary cooperation, Road-map for adoption, Summary, Summary


What does promise theory say about collaborative authoring?

First of all, it begins by saying that each individual in the process
of authoring has independent knowledge and should be represented as a
separate agent. It tells us that promises to cooperate will be needed
to integrate the information.

However, more than that, promises tell us that each section of the
text is an ``agent'' which can change or behave independently. In
other words, we can manage the parts independently, but again we need
to promise to coordinate those parts. So promise theory asks us first
to identify the agents (the topics in the document) that will be
interacting and then find out what promises they need to make to carry
out their function.

Because of the individual nature of the parts, we can associate an
individual author to each. To bring them together we need a further
agent or individual to collate independent ideas and policy sources
into a single coherent whole. Thus promises shows us a basic
``bow-tie'' structure for integrating and correlating independent
sources and then making the results available to independent users
(see figure).  This is not the only solution to the
problem of vetting that promises predicts, but it is the simplest
one. Also it is the approach that ITIL approves -- making a someone
responsible for the job.

We emphasize that promise theory does not tell us the specifics of how
to implement solutions, it only tells us what elements are needed and
how they should interact. So we might implement agents as people, as
different computers, or as different user accounts within the same computer.
As long as the elements can keep the necessary promises, it does not matter.


So how did we write our document?  In fact we did not use a very
strict ITIL-like change management process when writing the first
versions of our document. Such a process could have strangled our work
in the creative stage and doubled the time it took to write.  Rather, we worked
in an @emph{ad hoc} way by voluntary cooperation. Each of us promised
to write about certain topics and work on the text independently. We
worked as autonomous agents, and we used Subversion (a version control
and sharing system) to keep the working document. Subversion is itself
a third agent which promises to accept changes one at a time from
either of the two authors and then make these changes available again
to both authors. This agent performs no vetting or control other than
ordering the changes.

The authors have to promise to one another to resolve any conflicts or
disagreements, but promises do not suggest how this might take place.
(ITIL, on the other hand, does offer suggestions for this resolution process).

ITIL seems to work best once a service is up and running, or once a
basic version of a document exists. It does not say so much about the
creative act, except to think of it as a release.

What ITIL is weak at is parallelization of effort. ITIL's processes are
serialized processing models.  In our first creative versions, we
converged in parallel onto an approximate result, each working
separately. This is very efficient but it can lead to duplication of
work or inconsistency. Serialization is needed to resolve consistency
issues precisely, but it leads to unnecessary waiting in some cases.


@node Road-map for adoption,  , How we wrote this document, Summary
@section Road-map for adoption

Below we indicate a checklist of ITIL compliant steps for using CFEngine
in a machine life-cycle.


@enumerate
@item Set up cfagent running at scheduled interval X. This is the Service Level Agreement.

@item Set up versioning of policy.

@item Set up delegation of authorship.

@item Run cfenvd for passive monitoring. Run cfagent for active monitoring.

@end enumerate

Release:

@enumerate

@item Select installation medium e.g. DVD, net-boot with hooks to CFEngine.

@item Start with essential promises, and formulate the configuration policy.

@item Use ITIL processes for deciding and refining configuration promises.

@item Evaluation and monitoring of promises using cfagent and cfenvd.

@item Use cfagent for monitor changes using cryptographic checksums.

@item Develop recovery plans. Use CFEngine to automate backup of data and
automate the duplication of servers for load balancing and redundancy.

@end enumerate




@c --------------------------------------------------------------------

@node ITIL glossary,  , Summary, Top
@chapter ITIL glossary

This section lists some of the many terms from ITIL, especially the ISO/IEC 20000
version of the text, and offers some comments and translations into common CFEngine
terminology.



@menu
* Active Monitoring::           
* Availability::                
* Alert::                       
* Audit ::                      
* Baseline::                    
* Benchmark ::                  
* Capability::                  
* Change record::               
* Chronological Analysis::      
* Configuration::               
* Configuration Item (CI)::     
* Configuration Management Database CMDB ::  
* Document::                    
* Emergency Change::            
* Error::                       
* Event::                       
* Exception::                   
* Failure::                     
* Incident::                    
* Monitoring::                  
* Passive Monitoring::          
* Policy::                      
* Proactive Monitoring::        
* Problem::                     
* Promise::                     
* Reactive Monitoring::         
* Record::                      
* Recovery::                    
* Remediation::                 
* Repair::                      
* Release::                     
* Request for Change::          
* Resilience::                  
* Restoration::                 
* Role::                        
* Service desk::                
* Service Level Agreement::     
* Service Management::          
* Warning::                     
@end menu

@node Active Monitoring, Availability, ITIL glossary, ITIL glossary
@section Active Monitoring

Monitoring of a configuration item or IT service that uses automated regular checks to discover the current status.

@cartouche
CFEngine performs programmed checks of all of its promises each time cfagent is started. 
Cfagent is, in a sense, an active monitor for a set of promises that are described in its
configuration file.
@end cartouche

@node Availability, Alert, Active Monitoring, ITIL glossary
@section Availability

The ability of a component or service to perform its required function.

Availability = Hours operational / Agreed service hours


@cartouche
Availability or intermittency in CFEngine refers to the responsiveness of 
hosts in a network when remotely connecting to cfservd.

Intermittency = Successful~ attempts / Total Attempts

@end cartouche
This is a measurement that cfagent automatically makes.

@node Alert, Audit , Availability, ITIL glossary
@section Alert

A warning that a threshold has been reached, something has changed or a failure has occurred. 


@cartouche
A CFEngine alert fits this description quite well. 
Most alerts are user-defined, but a few are side effects of certain configuration 
rules.
@end cartouche

@node Audit , Baseline, Alert, ITIL glossary
@section Audit 


A formal inspection and verification to check whether a standard or
set of guidelines is being followed.




@cartouche
CFEngine's notion of an audit is more like the notion from system
accounting. However, the data generated by this extra logging
information could be collected and used in a more detailed examination
of CFEngine's operations, suitable for use in a formal inspection
(e.g. for compliance).  
@end cartouche


@node Baseline, Benchmark , Audit , ITIL glossary
@section Baseline


A snapshot of the state of a service or an individual configuration
item at a point in time


@cartouche
In CFEngine parlance, we refer to this as an initial state or
configuration.  In principle a CFEngine initial state does not have to
be a known-base line, since the changes we make will not generally be
relative to an existing configuration. CFEngine encourages users to
define the final state (regardless of initial state). 
@end cartouche


@node Benchmark , Capability, Baseline, ITIL glossary
@section Benchmark 

The recorded state of something at a specific point in time. 


@cartouche
CFEngine does not use this term in any of its documentation, though
our general understanding of a ``benchmark'' is that of a standardized
performance measurement under special conditions. CFEngine regularly
records state and performance data in a variety of ways, for example
when making file copies.
@end cartouche

@node Capability, Change record, Benchmark , ITIL glossary
@section Capability

The ability of someone or something to carry out an activity.


@cartouche
CFEngine does not use this concept specifically. The notion of a capability
is terminology used in role-based access control.
@end cartouche

@node Change record, Chronological Analysis, Capability, ITIL glossary
@section Change record

A record containing details of which configuration items are affected
and how they are affected by an authorized change.



@cartouche
CFEngine's default modus operandi is to @emph{not} record changes made
to a system unless requested by the user. Changes can be written as
log entries or audit entries by switching on reporting.@end cartouche

Consider a typical CFEngine promise (to ensure that a destination file
is a copy of a source). Three levels of change recording can be
added in CFEngine 2:
@smallexample

copy:

  /source/file dest=/destination/file

               inform=true
               syslog=true
               audit=true
@end smallexample
An ``inform'' promise means that cfagent promises to notify the
changes to its standard output (which is usually sent by email or
printed on a console output). A ``syslog'' promise implies that
cfagent will log the message to the system log daemon. Both of the
foregoing messages give only a simple message of actual changes.  An
``audit'' promise is a promise to record extensive details about the
process that cfagent undergoes in its checking of other promises.


@node Chronological Analysis, Configuration, Change record, ITIL glossary
@section Chronological Analysis

An analysis based on the timeline of recorded events (used to help identify possible causes of problems). 

 

@cartouche
A timeline analysis could easily be carried out based on audit
information, system logs and cfenvd behavioural records.
@end cartouche

@node Configuration, Configuration Item (CI), Chronological Analysis, ITIL glossary
@section Configuration

A group of configuration items (CI) that work together to deliver an IT service. 

@cartouche
A configuration is the current state of resources on a system. This is, in
principle, different from the state we would like to achieve, or what has
been promised.
@end cartouche

@node Configuration Item (CI), Configuration Management Database CMDB , Configuration, ITIL glossary
@section Configuration Item (CI)

A component of an infrastructure which is or will be under the control
of configuration management.


@cartouche
A configuration item is any object making a promise
in CFEngine. We often speak of the promise object, or ``promiser''.@end cartouche

@node Configuration Management Database CMDB , Document, Configuration Item (CI), ITIL glossary
@section Configuration Management Database (CMDB)

Database containing all the relevant details of each configuration
item and details of the important relationships between them.

 
@cartouche

CFEngine has no asset database except for its own list of
promises. The only relationships is cares about are those which are
explicitly coded as promises. In the future, CFEngine 3 is likely
to extend the notion of promises to allow more general records of the
CMDB kind, but only to the extent that they can be verified autonomically.
@end cartouche

@node Document, Emergency Change, Configuration Management Database CMDB , ITIL glossary
@section Document

Information and its supporting medium.



@cartouche
ITIL originally considered a document to be only a container for
information. In version 3 it considers also the medium on which
the data are recorded, i.e. both the file and the filesystem on which it resides.@end cartouche

@node Emergency Change, Error, Document, ITIL glossary
@section Emergency Change

A change that must be introduced as soon as possible -- for example to
solve a major incident or to implement a critical security patch.

  

@cartouche
CFEngine has no specific concept for this.
@end cartouche

@node Error, Event, Emergency Change, ITIL glossary
@section Error

A design flaw or malfunction that causes a failure.

  

@cartouche
CFEngine often uses the term configuration error to mean a deviation of
a configuration from its promised state. The ITIL meaning of the term would
translated into ``bug in the CFEngine software'' or ``bug in the 
promised configuration''.
@end cartouche


@node Event, Exception, Error, ITIL glossary
@section Event

A change of state that has significance for the management of a
configuration item or IT service.

 

@cartouche
The same basic definition applies to CFEngine also, but CFEngine makes
all such events into @emph{classes}, since its approach to observing
the environment is to measure and then classify it into approximate
expected states.  CFEngine class attributes (usually from cfenvd) may
be considered as event notifications as they change.
@end cartouche

@node Exception, Failure, Event, ITIL glossary
@section Exception, Failure, Event, Summary

An @b{event} that is generated when a service or device is currently operating abnormally. 

 

@cartouche
A state in which configuration policy is violated (could lead to a
warning or an automated correction).
@end cartouche


@node Failure, Incident, Exception, ITIL glossary
@section Failure

Loss of ability to operate to specification or to deliver the required output.

 

@cartouche
ITIL's idea of a failure is something that prevents a promise from being kept.
CFEngine's autonomy model means that it is unlikely for such a failure
to occur, since promises are only allowed to be made about resources for which
we have all privileges. Occasionally, environmental issues might interfere and
lead to failure.
@end cartouche

@node Incident, Monitoring, Failure, ITIL glossary
@section Incident

Any event that is not expected in normal operations and which might
cause a degradation of service quality.

 

@cartouche
CFEngine's philosophy of convergence gives us only one option for
interpreting this term, namely as a temporary deviation from promised
behaviour. A deviation must be temporary if CFEngine is operating
continually, since it will repair any problem on its next invocation
round. Events which do not impact promises made by CFEngine are of no
interest to CFEngine, since autonomy means it cannot be responsible
for anything beyond its own promises.
@end cartouche

@node Monitoring, Passive Monitoring, Incident, ITIL glossary
@section Monitoring

Repeated observation of a configuration item, IT service or process in
order to detect events and ensure that the current status is known.

  

@cartouche
CFEngine incorporates a number of different kinds of monitoring, including monitoring of kept
configuration-promises and passive monitoring of behaviour.
@end cartouche

@node Passive Monitoring, Policy, Monitoring, ITIL glossary
@section Passive Monitoring

Monitoring of a configuration item or IT service that relies on an alert or notification to discover the current status.

  

@cartouche
Cfenvd is CFEngine's passive monitoring component. It observes system
related behaviour and learns about it. It assumes that there is likely
to be a weekly periodicity in the data in order to best handle its
statistical inference.
@end cartouche

@node Policy, Proactive Monitoring, Passive Monitoring, ITIL glossary
@section Policy

Formally documented management expectations and intentions. Policies
are used to direct decisions, and to ensure consistent and appropriate
development and implementation of processes, standards, roles,
activities, IT infrastructures, etc.
  

@cartouche
CFEngine's configuration policy is an automatable set of promises
about the static and runtime state of a computer. Roles are identified
by the kinds of behaviour exhibited by resources in a network. We say
that a number of resources (hosts or smaller configuration objects)
play a specific promised role if they make identical promises. Any resource can 
play a number of roles. Decisions in CFEngine are made entirely on the basis
of the result of monitoring a host environment.
@end cartouche

@node Proactive Monitoring, Problem, Policy, ITIL glossary
@section Proactive Monitoring, Problem, Policy, Summary

Monitoring that looks for patterns of events to predict possible future failures.

  

@cartouche
All CFEngine monitoring is pro-active in the sense that it can lead to automated follow-up actions.
@end cartouche

@node Problem, Promise, Proactive Monitoring, ITIL glossary
@section Problem

Unknown underlying cause of one or more incidents. 

 

@cartouche
A repeated deviation from policy that suggests a change of policy or
specific counter-measures. A promise needs to be reconsidered or new promises
are required.
@end cartouche

@node Promise, Reactive Monitoring, Problem, ITIL glossary
@section Promise, Reactive Monitoring, Problem, Summary

ITIL does not define this term, although promises are deployed in
various ways -- for instance in terms of cooperation, communication
interfaces within or between processes or contractual relationships as
defined by Service Level Agreements, Operational Level Agreements and
Underpinning Contracts.

  

@cartouche
A promise in CFEngine is a single rule in the CFEngine language. The promiser is the resource
whose properties are described, and the promisee is implicitly the CFEngine monitor.
@end cartouche

@node Reactive Monitoring, Record, Promise, ITIL glossary
@section Reactive Monitoring

Monitoring that takes action in response to an event -- for example
submitting a batch job when the previous job completes, or logging an
incident when an error occurs.



@cartouche
The concept of reactive monitoring is unclear because the duration of an event and the speed of
a response are undefined. In a sense, all CFEngine monitoring is potentially reactive. It is possible
to attach actions which keep promises to any observable condition discernable by CFEngine's monitor.
CFEngine is not usually considered event driven however, since it does not react ``as soon as possible''
but at programmed intervals.
@end cartouche

@node Record, Recovery, Reactive Monitoring, ITIL glossary
@section Record

Information in readable form that is maintained by the service provider about operations. 

 

@cartouche
A log entry or database item.
@end cartouche

@node Recovery, Remediation, Record, ITIL glossary
@section Recovery

Returning a Configuration Item or an IT service to a working
state. Recovering of an IT service often includes recovering data to a
known consistent state.

 

@cartouche
All CFEngine promises refer to the state of a system that is desired. The promises are
automatically enforced, hence CFEngine recovers a system (in principle) on every invocation.
CFEngine always returns to a known state, due to the property of ``convergence''. There is no
distinction between the concepts of repair, recovery or remediation.
@end cartouche

@node Remediation, Repair, Recovery, ITIL glossary
@section Remediation

Recovery to a known state after a failed change or release.

 

@cartouche
All CFEngine promises refer to the state of a system that is desired. The promises are
automatically enforced, hence CFEngine recovers a system (in principle) on every invocation.
CFEngine always returns to a known state, due to the property of ``convergence''. There is no
distinction between the concepts of repair, recovery or remediation. 

However, this concept is like the notion of ``rollback'' which often involves a more
significant restoration of a system from backup. This is discussed later.
@end cartouche

@node Repair, Release, Remediation, ITIL glossary
@section Repair

The replacement or correction of a failed configuration item.

 

@cartouche
All CFEngine promises refer to the state of a system that is desired. The promises are
automatically enforced, hence CFEngine recovers a system (in principle) on every invocation.
CFEngine always returns to a known state, due to the property of ``convergence''. There is no
distinction between the concepts of repair, recovery or remediation.@end cartouche

@node Release, Request for Change, Repair, ITIL glossary
@section Release, Request for Change, Repair, Summary

A collection of new or changed configuration items that are introduced together.

 

@cartouche
An instantiation of the entire CFEngine system under a specific
version of a policy, i.e. a specific set of promises.
@end cartouche

@node Request for Change, Resilience, Release, ITIL glossary
@section Request for Change

A form to be completed requesting the need for change. This is to be followed up.

 

@cartouche
This has no counterpart in CFEngine. It is part of human communication
which coordinates autonomous machines. Clearly autonomous computers do not
listen to change requests from other computers, but when machines cooperate
in clusters or groups they take suggestions from the collaborative process.
An RFC in an ITIL sense is part of an organizational process that goes beyond
 CFEngine's level of jurisdiction. This is an example of what ITIL adds to
the autonomous CFEngine model.
@end cartouche

@menu
* Abandon Autonomy?::           
@end menu

@node Abandon Autonomy?,  , Request for Change, Request for Change
@subsection Abandon Autonomy?

Why not simply abandon autonomy of machines if this seems to interfere
with the need for organizational change? There are good reasons why
autonomy is the correct model for resources.  Autonomy reduces the risk to a
resource of attack, mistake and error propagation.  

ITIL's processes exist precisely to minimize the risk of negative
impact of change, so the goals are entirely compatible. When an organization
discusses a change it examines information from possible several autonomous
systems and discusses how they will change their pattern of collaboration.
There is no point in this process at which it is necessary for one of the
systems to give up its autonomy.


@node Resilience, Restoration, Request for Change, ITIL glossary
@section Resilience

The ability of a configuration item or IT service to resist failure or to recover quickly following a failure.

 

@cartouche
CFEngine's purpose is to make a system resilient to unpredictable change.@end cartouche

@node Restoration, Role, Resilience, ITIL glossary
@section Restoration

Actions taken to return an IT service to the users after repair and recovery from an incident.

 

@cartouche
All CFEngine promises refer to the state of a system that is desired. The promises are
automatically enforced, hence CFEngine recovers a system (in principle) on every invocation.
CFEngine always returns to a known state, due to the property of ``convergence''. There is no
distinction between the concepts of repair, recovery or remediation.

However, this concept seems to suggest a more catastrophic failure
which often involves a more significant restoration of a system from
backup. This is discussed later.  
@end cartouche

@node Role, Service desk, Restoration, ITIL glossary
@section Role

A set of responsibilities, activities and authorities granted to a person or a team. Roles are defined in processes.

 

@cartouche
A role in CFEngine is a class of agents that make the same kind of promise. The type
of role played by the class is determined by the nature of the promise they make. e.g.
a promise to run a web server would naturally lead to the role ``web server''.
@end cartouche

@node Service desk, Service Level Agreement, Role, ITIL glossary
@section Service desk

Interface between users and service provider. 

 

@cartouche
A help desk. This is not formally part of CFEngine's tool set.
@end cartouche

@node Service Level Agreement, Service Management, Service desk, ITIL glossary
@section Service Level Agreement

A written agreement between the service provider that documents agreed
services, levels and penalties for non-compliance.

 

@cartouche
An agreement assumes a set of promises that propose behaviour and an
acceptance of those promises by the client. If we assume that the
users are satisfied with out policies, then an SLA can be
interpreted as a combination of a configuration policy
(configuration service promises), and the CFEngine execution
schedule. 
@end cartouche


@node Service Management, Warning, Service Level Agreement, ITIL glossary
@section Service Management

 The management of services. 

 

@cartouche
Same.@end cartouche

@node Warning,  , Service Management, ITIL glossary
@section Warning

An @b{event} that is generated when a service or device is approaching its threshold. 

 

@cartouche
A message generated in place of a correction to system state when a deviation from policy is detected.
Note that CFEngine is not based on fixed thresholds. All ``thresholds'' for action or warning
are defined as a matter of policy.
@end cartouche





@c =========================================================================
@c @node Index,  , CFEngine Methods, Top
@c @unnumbered Concept Index
@c @printindex cp
@c =========================================================================


@ifhtml
@html
<a name="Contents">
@contents
@end html
@end ifhtml


@ifhtml
@html
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
@end html
@end ifhtml

@bye

